<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CHRONO-CYCLES v8.3 - STABLE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&family=Share+Tech+Mono&display=swap');

        :root {
            --bg: #050508;
            --panel: rgba(8, 8, 10, 0.95);
            --border: 1px solid rgba(255, 255, 255, 0.15);
            --accent: #ff3333;
            --inf-accent: #bd00ff;
            --reality-gold: #ffd700;
            --shop-grad: linear-gradient(135deg, #ff00cc, #3333ff);
            --text-main: #eee;
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg); color: var(--text-main);
            font-family: 'Rajdhani', sans-serif;
            display: flex; height: 100vh; user-select: none;
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 0; touch-action: none; }

        /* LOADING SCREEN */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 1s;
        }
        .loader-text {
            font-family: 'Orbitron'; color: #40e0d0; font-size: 2rem; letter-spacing: 5px;
            animation: pulse 1s infinite alternate;
        }
        .loader-bar {
            width: 300px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden;
        }
        .loader-progress {
            position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: #40e0d0;
            box-shadow: 0 0 20px #40e0d0;
            animation: load 3s ease-in-out forwards;
        }
        @keyframes load { 0% { width: 0%; } 100% { width: 100%; } }
        @keyframes pulse { from { opacity: 0.5; text-shadow: 0 0 10px #40e0d0; } to { opacity: 1; text-shadow: 0 0 30px #40e0d0; } }
        @keyframes pulse-glow { 0% { box-shadow: 0 0 10px rgba(189,0,255,0.5); } 50% { box-shadow: 0 0 25px rgba(189,0,255,0.9); } 100% { box-shadow: 0 0 10px rgba(189,0,255,0.5); } }
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(200%); } }
        @keyframes text-glow { 0%, 100% { text-shadow: 0 0 20px rgba(255,255,255,0.8); } 50% { text-shadow: 0 0 30px rgba(255,255,255,1), 0 0 40px rgba(189,0,255,0.6); } }

        /* TOP RIGHT UI */
        .top-right-ui {
            position: fixed; top: 20px; right: 20px; z-index: 9001;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
        }
        .icon-row { display: flex; gap: 15px; }
        .icon-btn {
            font-size: 1.5rem; color: #666; cursor: pointer; transition: 0.3s;
            background: none; border: none; padding: 5px;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.1); }
        
        #settings-hint {
            display: none; color: #40e0d0; font-family: 'Share Tech Mono'; font-size: 0.8rem;
            animation: bounceDown 1s infinite; margin-right: 5px; text-align: right;
        }
        @keyframes bounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        /* MODALS */
        .modal {
            position: fixed; top: 70px; right: 20px; width: 300px;
            background: rgba(10, 10, 15, 0.98); border: 1px solid #444;
            padding: 15px; display: none; flex-direction: column; gap: 15px;
            z-index: 9001; box-shadow: 0 5px 20px rgba(0,0,0,0.8);
            max-height: 80vh; overflow-y: auto;
        }
        
        #shop-modal, #forge-modal, #challenges-modal {
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 500px; right: auto;
        }
        
        /* MANUAL MODAL STYLING */
        #manual-modal {
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; right: auto; height: 500px;
            background: #08080a; border: 2px solid #4488ff;
            box-shadow: 0 0 50px rgba(68, 136, 255, 0.2);
        }
        .manual-content {
            display: grid; grid-template-columns: 150px 1fr; gap: 20px; height: 100%;
        }
        .manual-nav { border-right: 1px solid #333; display: flex; flex-direction: column; gap: 5px; }
        .manual-tab {
            padding: 10px; cursor: pointer; color: #888; font-family: 'Orbitron'; font-size: 0.8rem;
            text-align: left; background: none; border: none; transition: 0.2s;
        }
        .manual-tab:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .manual-tab.active { color: #4488ff; border-left: 2px solid #4488ff; background: rgba(68, 136, 255, 0.1); }
        
        .manual-page { display: none; overflow-y: auto; padding-right: 10px; }
        .manual-page.active { display: block; }
        .manual-header { font-family: 'Orbitron'; color: #fff; font-size: 1.5rem; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .manual-text { font-family: 'Share Tech Mono'; color: #ccc; font-size: 0.9rem; line-height: 1.6; }
        .manual-highlight { color: #4488ff; font-weight: bold; }

        .modal.open { display: flex; }
        .setting-row { display: flex; flex-direction: column; gap: 5px; }
        .setting-label { font-family: 'Share Tech Mono'; font-size: 0.8rem; color: #aaa; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }
        .toggle-btn {
            background: #222; border: 1px solid #444; color: #888; padding: 8px;
            cursor: pointer; font-family: 'Share Tech Mono'; font-size: 0.8rem; width: 100%;
            transition: 0.2s;
        }
        .toggle-btn:hover { background: #333; color: #fff; }
        .toggle-btn.active { background: var(--accent); color: black; border-color: var(--accent); font-weight: bold; }
        .layer-toggle { padding: 4px 8px; font-size: 0.7rem; flex: 0 0 auto; min-width: 60px; text-align: center; }

        .ach-list-item {
            background: rgba(255,255,255,0.05); border: 1px solid #333; padding: 10px;
            display: flex; gap: 10px; align-items: center;
        }
        .ach-list-item.locked { opacity: 0.5; filter: grayscale(1); }
        .ach-icon-sm { font-size: 1.2rem; }

        .shop-item, .forge-item {
            background: rgba(255,255,255,0.05); border: 1px solid #555; padding: 10px;
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
        }
        .shop-btn {
            background: var(--shop-grad); border: none; color: white;
            padding: 5px 10px; font-weight: bold; cursor: pointer; font-family: 'Orbitron'; font-size: 0.7rem; min-width: 80px;
        }
        .forge-btn {
            background: linear-gradient(135deg, #bd00ff, #000); border: 1px solid #bd00ff; color: white;
            padding: 8px; font-weight: bold; cursor: pointer; font-family: 'Orbitron'; font-size: 0.8rem;
            transition: 0.3s;
        }
        .shop-btn:disabled, .forge-btn:disabled { opacity: 0.5; filter: grayscale(1); cursor: not-allowed; }
        .shop-btn.owned, .forge-btn.owned { background: #33ff33; color: black; pointer-events: none; border:none;}
        .forge-btn:hover:not(:disabled) { background: #bd00ff; box-shadow: 0 0 15px #bd00ff; }

        #event-banner {
            position: fixed; bottom: -150px; left: 50%; transform: translateX(-50%);
            width: 450px; background: #111; border: 2px solid #fff;
            padding: 20px; z-index: 8000; text-align: center;
            transition: bottom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border-radius: 10px 10px 0 0;
        }
        #event-banner.active { bottom: 0; }
        .evt-solar { background: linear-gradient(180deg, #620 0%, #111 100%) !important; border-color: #f80 !important; }
        .evt-time { background: linear-gradient(180deg, #024 0%, #111 100%) !important; border-color: #40e0d0 !important; }
        .evt-warp { background: linear-gradient(180deg, #404 0%, #111 100%) !important; border-color: #f0f !important; }
        .evt-void { background: linear-gradient(180deg, #222 0%, #000 100%) !important; border-color: #888 !important; }
        .evt-frenzy { background: linear-gradient(180deg, #500 0%, #202 100%) !important; border-color: #f00 !important; }

        .event-title { font-family: 'Orbitron'; font-weight: 900; color: #fff; font-size: 1.4rem; margin-bottom: 5px; text-transform: uppercase; text-shadow: 0 0 10px currentColor; }
        .event-desc { font-family: 'Share Tech Mono'; color: #ccc; font-size: 1rem; margin-bottom: 10px; }
        .event-timer-bar { width: 100%; height: 6px; background: rgba(0,0,0,0.5); position: relative; border-radius: 3px; overflow: hidden; }
        .event-timer-fill { height: 100%; background: #fff; width: 100%; transition: width 0.1s linear; }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; justify-content: space-between;
        }

        .control-panel {
            width: 460px; background: var(--panel); border-right: var(--border);
            padding: 0; pointer-events: auto;
            display: flex; flex-direction: column;
            box-shadow: 10px 0 50px rgba(0,0,0,0.8);
        }

        .header {
            padding: 15px; background: linear-gradient(to bottom, rgba(255,255,255,0.03), transparent);
            border-bottom: 1px solid #333;
        }
        .header h1 { margin: 0; font-family: 'Orbitron'; font-weight: 900; font-size: 1.6rem; color: #fff; text-shadow: 0 0 10px var(--accent); }

        #warp-btn {
            display: none; margin-top: 15px; width: 100%; padding: 20px;
            background: linear-gradient(90deg, #000, #40e0d0, #000);
            background-size: 200% 200%;
            border: 2px solid #40e0d0; color: #fff;
            font-family: 'Orbitron'; font-weight: 900; letter-spacing: 3px; font-size: 1.1rem;
            cursor: pointer; animation: pulseCyan 3s infinite alternate, shine 3s infinite linear;
            text-shadow: 0 0 10px #40e0d0;
        }
        
        #return-btn {
            display: none; margin-top: 15px; width: 100%; padding: 15px;
            background: #111; border: 1px solid #666; color: #888;
            font-family: 'Orbitron'; cursor: pointer; transition: 0.3s;
        }
        #return-btn:hover { background: #222; color: #fff; border-color: #fff; }

        @keyframes pulseCyan { 0% { box-shadow: 0 0 10px #40e0d0; } 100% { box-shadow: 0 0 30px #40e0d0; } }
        @keyframes shine { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        #warp-btn:hover { color: #000; background: #40e0d0; }

        #prestige-container { display: none; }
        
        .prestige-box {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 1px solid #4488ff; padding: 12px; margin-top: 10px;
            border-radius: 4px; display: flex; justify-content: space-between; align-items: center;
        }
        .chronon-display { color: #4488ff; font-weight: bold; font-family: 'Orbitron'; font-size: 1.1rem; }
        .prestige-btn {
            background: #4488ff; color: #000; border: none; padding: 8px 15px;
            font-family: 'Orbitron'; font-size: 0.7rem; cursor: pointer; font-weight: bold; width: 150px;
        }
        .prestige-btn:hover { background: #fff; }
        .prestige-btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555; color: #ccc; }

        .shop-open-btn {
            margin-top: 5px; width: 100%; padding: 8px;
            background: var(--shop-grad); border: none; color: white;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .shop-open-btn:hover { filter: brightness(1.2); }

        .forge-open-btn {
            margin-top: 15px; width: 100%; padding: 12px;
            background: #000; border: 1px solid #bd00ff; color: #bd00ff;
            font-family: 'Orbitron'; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 10px rgba(189, 0, 255, 0.2);
            transition: 0.3s;
            display: none; 
        }
        .forge-open-btn:hover { background: #bd00ff; color: #000; box-shadow: 0 0 20px #bd00ff; }

        .mult-controls { display: flex; gap: 5px; margin-top: 10px; margin-bottom: 10px; }
        .mult-btn {
            flex: 1; background: #222; border: 1px solid #444; color: #888;
            font-family: 'Share Tech Mono'; cursor: pointer; padding: 5px;
            transition: 0.2s;
        }
        .mult-btn:hover { background: #333; color: #fff; }
        .mult-btn.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: bold; }

        .rpm-wrapper { margin-top: 10px; }
        .rpm-summary {
            background: #080808; border: 1px solid #333; padding: 10px; border-radius: 4px;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
            transition: 0.2s;
        }
        .rpm-summary:hover { border-color: #666; }
        .rpm-list {
            display: none; background: #050505; border: 1px solid #333; border-top: none;
            max-height: 150px; overflow-y: auto;
        }
        .rpm-list.open { display: block; }
        .rpm-item {
            padding: 8px 10px; font-family: 'Share Tech Mono'; font-size: 0.8rem;
            border-bottom: 1px solid #222; display: flex; justify-content: space-between;
            color: #888;
        }
        .rpm-val { color: #fff; }
        .rpm-boost { font-size: 0.7rem; color: #0f0; margin-left: 5px; }

        .scroll-area { flex: 1; overflow-y: auto; padding: 20px; }
        .scroll-area::-webkit-scrollbar { width: 4px; }
        .scroll-area::-webkit-scrollbar-thumb { background: #444; }

        .layer-group { margin-bottom: 30px; position: relative; }
        .layer-header {
            font-family: 'Orbitron'; font-size: 1.1rem; color: var(--layer-color);
            border-bottom: 2px solid var(--layer-color); margin-bottom: 10px;
            padding-bottom: 5px; text-transform: uppercase; letter-spacing: 2px; font-weight: bold;
            text-shadow: 0 0 10px var(--layer-color);
            display: flex; justify-content: space-between; align-items: center;
        }
        
        .overclock-btn {
            background: transparent; border: 1px solid var(--layer-color);
            color: var(--layer-color); font-size: 0.9rem; padding: 5px 10px;
            cursor: pointer; font-family: 'Orbitron'; transition: 0.2s;
            display: none; 
            font-weight: bold; border-radius: 4px;
            animation: pulseGlow 2s infinite;
        }
        .overclock-btn.visible { display: block; }
        
        .eye-btn {
            background: none; border: none; color: #666; cursor: pointer; font-size: 1rem; margin-right: 10px;
        }
        .eye-btn:hover { color: #fff; }
        .eye-btn.disabled { color: #333; }
        
        @keyframes pulseGlow { 0% { box-shadow: 0 0 5px var(--layer-color); } 50% { box-shadow: 0 0 15px var(--layer-color); } 100% { box-shadow: 0 0 5px var(--layer-color); } }
        .overclock-btn:hover { background: var(--layer-color); color: #000; }

        .upgrade-card {
            background: rgba(255,255,255,0.03); 
            border: 1px solid rgba(255,255,255,0.1); 
            padding: 15px; margin-bottom: 10px; border-radius: 4px;
            cursor: pointer; transition: 0.1s; position: relative;
            display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: center;
        }
        .upgrade-card:hover { background: rgba(255,255,255,0.08); transform: translateX(5px); }
        .upgrade-card:active { transform: scale(0.99); }
        .upgrade-card.locked { opacity: 0.5; filter: grayscale(1); pointer-events: none; border-color: transparent !important; }

        .u-info { display: flex; flex-direction: column; }
        .u-name { font-weight: 700; color: #fff; font-size: 1.1rem; font-family: 'Rajdhani'; }
        .u-desc { font-size: 0.8rem; color: #888; line-height: 1.2; margin-top: 3px; }
        .u-current { font-size: 0.8rem; color: #66f; margin-top: 2px; font-weight: bold; }
        
        .u-meta { text-align: right; display: flex; flex-direction: column; align-items: flex-end; }
        .u-cost { font-family: 'Share Tech Mono'; color: var(--layer-color); font-size: 1rem; font-weight: bold; }
        .u-lvl { font-size: 0.85rem; color: #777; font-family: 'Share Tech Mono'; margin-top: 2px; }

        .center-hud {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: auto; z-index: 20;
        }
        .shards-val { 
            font-size: 5rem; font-family: 'Orbitron'; font-weight: 700; 
            color: #fff; text-shadow: 0 0 30px rgba(255, 255, 255, 0.2); line-height: 1;
        }
        
        #click-combo-container {
            margin-top: 10px; opacity: 0; transition: opacity 0.3s;
        }
        .combo-text { font-family: 'Orbitron'; font-size: 0.8rem; color: #ff3333; letter-spacing: 2px; }
        .combo-bar { width: 300px; height: 4px; background: #333; margin: 5px auto; position: relative; }
        .combo-fill { width: 0%; height: 100%; background: #ff3333; transition: width 0.1s linear; }

        .currency-select {
            position: relative; display: inline-block; margin-top: 10px;
        }
        .curr-btn {
            background: transparent; border: 1px solid transparent; color: #888;
            font-size: 1.2rem; letter-spacing: 4px; text-transform: uppercase; font-weight: 600;
            cursor: pointer; padding: 5px 15px; transition: 0.2s;
        }
        .curr-btn:hover { border-color: #444; color: #fff; background: rgba(0,0,0,0.5); }
        .curr-list {
            position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
            background: #111; border: 1px solid #444; min-width: 200px;
            display: none; flex-direction: column; max-height: 300px; overflow-y: auto;
        }
        .curr-list.show { display: flex; }
        .curr-opt {
            padding: 10px; color: #ccc; cursor: pointer; text-align: left; font-size: 0.9rem;
            border-bottom: 1px solid #222; font-family: 'Share Tech Mono';
        }
        .curr-opt:hover { background: #222; color: #fff; }

        #lore-box {
            position: fixed; bottom: 20px; right: 20px; width: 350px;
            background: rgba(0, 0, 0, 0.9); border: 1px solid #333;
            padding: 20px; border-radius: 0px; 
            border-left: 4px solid #fff;
            pointer-events: auto; z-index: 50;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            transition: 0.5s;
        }
        .lore-title { font-family: 'Orbitron'; font-size: 0.8rem; color: #666; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px;}
        .lore-text { font-family: 'Share Tech Mono'; font-size: 0.9rem; color: #ccc; line-height: 1.5; }
        .lore-blink { animation: blink 1s infinite; display: inline-block; width: 8px; height: 15px; background: #fff; vertical-align: middle; margin-left: 5px;}
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        
        #manual-btn {
            position: fixed; bottom: 20px; right: 380px; width: 40px; height: 40px;
            background: #111; border: 1px solid #444; border-radius: 50%;
            color: #fff; font-size: 1.2rem; cursor: pointer; z-index: 60;
            display: flex; align-items: center; justify-content: center;
        }
        #manual-btn:hover { background: #333; border-color: #888; }

        .popup-area {
            position: absolute; top: 160px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 100;
        }
        .achievement {
            background: rgba(0,0,0,0.95); border: 1px solid var(--c); border-left: 5px solid var(--c);
            padding: 15px 30px; display: flex; align-items: center; gap: 15px; width: 500px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); animation: slideDown 0.5s forwards;
        }
        @keyframes slideDown { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .ach-icon { font-size: 2rem; }
        .ach-text h3 { margin: 0; font-family: 'Orbitron'; color: var(--c); font-size: 1rem; }
        .ach-text p { margin: 5px 0 0; color: #ccc; font-size: 0.85rem; }

        .dev-toggle {
            position: fixed; bottom: 10px; right: 10px; background: #222; color: #444;
            border: 1px solid #333; width: 30px; height: 30px; border-radius: 50%;
            cursor: pointer; z-index: 9999; font-weight: bold; pointer-events: auto;
        }
        .dev-menu {
            position: fixed; bottom: 50px; right: 20px; width: 200px;
            background: #111; border: 1px solid #f44; padding: 10px;
            display: none; pointer-events: auto; z-index: 9999;
        }
        .dev-menu.open { display: block; }
        .dev-btn {
            width: 100%; background: #300; border: 1px solid #600; color: #f88;
            padding: 8px; margin-bottom: 5px; cursor: pointer; text-transform: uppercase; font-size: 0.7rem;
        }
        .dev-btn:hover { background: #f00; color: #fff; }

        .floater {
            position: absolute; pointer-events: none; 
            font-family: 'Share Tech Mono'; font-weight: bold; font-size: 1.5rem;
            animation: floatUp 1s forwards; text-shadow: 0 0 5px currentColor;
        }
        .gradient-text {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none !important;
            font-size: 2rem !important;
            font-weight: 900;
        }
        .reality-text {
            color: #ffd700 !important;
            text-shadow: 0 0 10px #ffaa00 !important;
            font-size: 3rem !important;
            z-index: 999;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }

        #reality-btn {
            margin-top: 15px; padding: 10px 30px; background: #000; border: 1px solid #fff;
            color: #fff; font-family: 'Orbitron'; letter-spacing: 5px; cursor: pointer;
            transition: 0.3s; animation: glitch 2s infinite; display: none;
        }
        #reality-btn:hover { background: #fff; color: #000; }
        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }

    </style>
</head>
<body>

    <div id="flash-overlay"></div>
    <div id="loading-screen">
        <div class="loader-text">ENTERING INFINITY</div>
        <div class="loader-bar"><div class="loader-progress"></div></div>
    </div>

    <div id="event-banner">
        <div class="event-title">EVENT TITLE</div>
        <div class="event-desc">Event description</div>
        <div class="event-timer-bar"><div class="event-timer-fill" id="event-fill"></div></div>
    </div>

    <div class="top-right-ui">
        <div class="icon-row">
            <button class="icon-btn" onclick="document.getElementById('ach-modal').classList.toggle('open'); UI.showAchievements()">üèÜ</button>
            <button class="icon-btn" onclick="document.getElementById('settings-modal').classList.toggle('open'); document.getElementById('settings-hint').style.display = 'none';">‚öô</button>
            <button class="icon-btn" onclick="document.getElementById('help-modal').classList.toggle('open')">‚ùì</button>
            <button class="icon-btn" id="profile-btn" onclick="document.getElementById('profile-modal').classList.toggle('open'); UI.buildProfileMenu()" style="display:none;">üë§</button>
        </div>
        <span id="settings-hint">You can turn points back on here &#8593;</span>
    </div>

    <div id="challenge-info-panel" style="position:fixed; right:20px; top:50%; transform:translateY(-50%); width:280px; background:rgba(0,0,0,0.85); border:2px solid #ffd700; padding:15px; border-radius:8px; z-index:100; display:none; color:#fff;">
        <div style="font-family:'Orbitron'; font-size:1rem; color:#ffd700; margin-bottom:10px; text-align:center;">ACTIVE CHALLENGE</div>
        <div id="challenge-info-name" style="font-weight:bold; font-size:0.9rem; margin-bottom:5px;"></div>
        <div id="challenge-info-desc" style="font-size:0.75rem; color:#aaa; margin-bottom:10px; line-height:1.4;"></div>
        <div style="font-size:0.7rem; color:#888; border-top:1px solid #444; padding-top:10px; margin-top:10px;">Reward:</div>
        <div id="challenge-info-reward" style="font-size:0.75rem; color:#0ff;"></div>
    </div>

    <div id="settings-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px;">SETTINGS</div>
        <div class="setting-row">
            <span class="setting-label">MASTER VOLUME</span>
            <input type="range" min="0" max="100" value="50" oninput="AudioSys.setMaster(this.value)">
        </div>
        <div class="setting-row">
            <span class="setting-label">SFX VOLUME</span>
            <input type="range" min="0" max="100" value="50" oninput="AudioSys.setSFX(this.value)">
        </div>
        <button class="toggle-btn" id="mute-ticks-btn" onclick="AudioSys.toggleTicks()">MUTE TICKS: OFF</button>
        <button class="toggle-btn active" id="floaters-btn" onclick="UI.toggleFloaters()">FLOATING TEXT: ON</button>
        <button class="toggle-btn" id="auto-select-material-btn" onclick="UI.toggleAutoSelectMaterial()">AUTO-SELECT MATERIAL: OFF</button>
        <button class="toggle-btn active" id="auto-toggle-btn" onclick="Game.toggleAutoBuy()" style="display:none;">AUTO-BUY: ON</button>
        <button class="toggle-btn" onclick="document.getElementById('autobuy-modal').classList.add('open'); UI.buildAutoBuyMenu()">‚öôÔ∏è LAYER AUTO-BUY</button>
        <div style="border-top:1px solid #333; margin-top:15px; padding-top:15px;">
            <button class="toggle-btn" onclick="Game.newGame()" style="background:#aa3344;">üÜï NEW GAME</button>
        </div>
    </div>

    <div id="help-modal" class="modal" style="width:300px;">
        <div style="color:#9966ff; font-weight:bold; text-align:center; margin-bottom:8px; font-size:14px;">HOW TO PLAY</div>
        <div style="color:#ccc; font-size:11px; line-height:1.5;">
            <p style="margin:6px 0;"><b style="color:#ff6666;">üîÑ CYCLES:</b> Click rings to generate resources.</p>
            <p style="margin:6px 0;"><b style="color:#66ff66;">‚¨ÜÔ∏è UPGRADES:</b> Speed, Value, Auto - boost production.</p>
            <p style="margin:6px 0;"><b style="color:#6699ff;">üåÄ LAYERS:</b> Max RPM unlocks new resource layers.</p>
            <p style="margin:6px 0;"><b style="color:#ffaa00;">üí´ PRESTIGE:</b> Reset for permanent Chronon bonuses.</p>
            <p style="margin:6px 0;"><b style="color:#aa66ff;">üõí SHOP:</b> Spend Chronons on powerful upgrades.</p>
            <p style="margin:6px 0;"><b style="color:#00ffff;">ü§ñ AUTO-BUY:</b> Auto-purchases for ALL layers!</p>
            <p style="margin:6px 0;"><b style="color:#bd00ff;">‚öíÔ∏è FORGE:</b> Craft permanent artifacts in Infinity.</p>
            <p style="margin:6px 0;"><b style="color:gold;">üëÅÔ∏è REALITY:</b> Use the Universe to power the Ultimate Engine.</p>
        </div>
        <button class="toggle-btn" onclick="document.getElementById('help-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="manual-modal" class="modal">
        <div class="manual-content">
            <div class="manual-nav">
                <button class="manual-tab active" onclick="UI.setManualPage(0, this)">1. BASICS</button>
                <button class="manual-tab" onclick="UI.setManualPage(1, this)">2. INFINITY</button>
                <button class="manual-tab" onclick="UI.setManualPage(2, this)">3. REALITY</button>
                <button class="manual-tab" onclick="UI.setManualPage(3, this)">4. CONSTELLATIONS</button>
                <button class="manual-tab" onclick="UI.setManualPage(4, this)">5. EVENTS</button>
            </div>
            
            <div id="man-page-0" class="manual-page active">
                <div class="manual-header" style="color:#ff6666;">THE CHRONO ENGINE</div>
                <div class="manual-text">
                    <p>The <span class="manual-highlight">Engine</span> consists of 10 concentric rings. Clicking a ring applies <b>Torque</b>, increasing its velocity (RPM).</p>
                    <p><b>Upgrades:</b><br>
                    - <span style="color:#66ff66">Perpetual Motor</span>: Maintains speed automatically.<br>
                    - <span style="color:#4488ff">Kinetic Lubricant</span>: Reduces friction.<br>
                    - <span style="color:#ffaa00">Matter Compression</span>: Increases value per rotation.</p>
                    <p>When you reach 50,000 Total Value, you can perform a <b>REWIND</b> (Prestige) to earn Chronons. Chronon gain is exponential - each 10x increase in value gives more Chronons.</p>
                    <p><b>Purify:</b> When all 3 upgrades reach level 10 (first time), you can Purify a layer for a +50% multiplier. Each subsequent Purify requires +5 more levels (15, 20, 25...).</p>
                    <p><b>Auto-Buy:</b> In Settings, use "LAYER AUTO-BUY" to enable/disable automatic upgrades for each layer individually. Costs scale exponentially per layer.</p>
                </div>
            </div>

            <div id="man-page-1" class="manual-page">
                <div class="manual-header" style="color:#bd00ff;">INFINITY DIMENSION</div>
                <div class="manual-text">
                    <p>Once all 10 layers reach <span class="manual-highlight">3,000 RPM</span>, the engine collapses into a Black Hole.</p>
                    <p>In this dimension, you collect <b>Essence</b>. This currency is used in the <span class="manual-highlight">Infinity Forge</span> to create permanent Artifacts that persist through all resets.</p>
                    <p>The <b>Void Siphon</b> upgrade automatically collects Essence for you. At level 10+, it provides exponential auto-gain.</p>
                    <p><b>‚öõÔ∏è Singularity Collapse:</b> When you reach 1 billion Essence (or have reached it before), you can collapse the Singularity to earn <span class="manual-highlight">Void Cores</span>. This resets all Infinity upgrades and Essence, but grants permanent upgrades that persist through all collapses. The "SINGULARITY COLLAPSE" button appears in Infinity mode once you reach 100 million Essence.</p>
                    <p><b>Void Cores</b> can be spent on permanent upgrades that persist through all collapses:</p>
                    <ul style="margin-left:20px; color:#aaa; margin-top:10px;">
                        <li><b>‚ö° Void Resonance:</b> Multiplies ALL essence gains (void particles, cosmic particles, clicks, auto-gain) by +10% per level</li>
                        <li><b>‚öõÔ∏è Quantum Efficiency:</b> Makes Infinity upgrade costs scale 5% slower per level, making it easier to reach higher levels</li>
                        <li><b>‚ú® Particle Density:</b> Start each run with +5 void particles per level</li>
                        <li><b>üåä Essence Cascade:</b> Lowers Void Siphon level required for auto-gain (each level reduces requirement by 2 levels)</li>
                    </ul>
                </div>
            </div>

            <div id="man-page-2" class="manual-page">
                <div class="manual-header" style="color:#ffd700;">REALITY</div>
                <div class="manual-text">
                    <p>The Ultimate Layer. Your entire previous universe becomes a tiny engine in the center.</p>
                    <p><b>The Mechanic:</b> The total RPM of your inner 10 rings is converted into <span class="manual-highlight">Reality Torque</span>.</p>
                    <p><b>Income:</b> You only gain Reality Shards when the massive Gold Ring completes a <span class="manual-highlight">Full Rotation</span>.</p>
                    <p><b>Clicking:</b> You can click the Reality ring (the large gold ring) to add torque directly, though it's less effective than clicking inner rings.</p>
                    <p><b>RPM Display:</b> Click any ring name in the RPM list to change which RPM is displayed in the main display. The Reality ring RPM is also shown in the list.</p>
                    <p><b>Profiles:</b> Use the Profile button (üë§) in the top-right to switch between different game states. Useful for trying different strategies without losing progress.</p>
                    <p><b>Strategy:</b> You must switch back and forth between the Microcosm (Inner) and Reality to optimize power.</p>
                </div>
            </div>

            <div id="man-page-3" class="manual-page">
                <div class="manual-header" style="color:#40e0d0;">CONSTELLATIONS</div>
                <div class="manual-text">
                    <p>As you accumulate Essence in the Infinity Dimension, stars in the background will slowly connect.</p>
                    <p><b>Effect:</b> Completing constellation lines passively boosts your <span class="manual-highlight">Essence Generation</span>.</p>
                    <p>More Essence = More Lines = More Multiplier.</p>
                    <p>The <b>Star Chart</b> artifact accelerates this process significantly.</p>
                </div>
            </div>

            <div id="man-page-4" class="manual-page">
                <div class="manual-header" style="color:#ff6b9d;">RANDOM EVENTS</div>
                <div class="manual-text" id="events-library">
                    <p>Random cosmic events occur during gameplay. Rare events are marked with ‚≠ê.</p>
                    <div id="events-list"></div>
                </div>
            </div>
        </div>
        <div style="text-align:right; margin-top:10px;">
            <button class="toggle-btn" style="width:auto; padding:5px 20px;" onclick="document.getElementById('manual-modal').classList.remove('open')">CLOSE DATABASE</button>
        </div>
    </div>

    <div id="ach-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px;">ACHIEVEMENTS</div>
        <div id="ach-list-container"></div>
        <button class="toggle-btn" onclick="document.getElementById('ach-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="shop-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px; background:var(--shop-grad); -webkit-background-clip:text; -webkit-text-fill-color:transparent;">CHRONON SHOP</div>
        <div style="text-align:center; color:#4488ff; font-family:'Orbitron'; font-size:0.8rem; margin-bottom:10px;">Available: <span id="shop-chronon-val">0</span></div>
        <div id="shop-items-container"></div>
        <button class="toggle-btn" onclick="document.getElementById('shop-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="forge-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px; color:#bd00ff;">THE INFINITY FORGE</div>
        <div style="text-align:center; color:#fff; font-family:'Orbitron'; font-size:0.8rem; margin-bottom:10px;">Permanence through Chaos</div>
        
        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">TIME PRISM</div>
                <div style="color:#aaa; font-size:0.7rem;">Reality Torque +10%</div>
                <div style="color:#666; font-size:0.7rem;">1T Time Shards + 1M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-prism" onclick="Game.buyArtifact('prism')">FORGE</button>
        </div>

        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">DARK MATTER ANCHOR</div>
                <div style="color:#aaa; font-size:0.7rem;">Click Combo doesn't decay</div>
                <div style="color:#666; font-size:0.7rem;">1T Dark Matter + 5M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-anchor" onclick="Game.buyArtifact('anchor')">FORGE</button>
        </div>

        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">STAR CHART</div>
                <div style="color:#aaa; font-size:0.7rem;">Reveals Constellations 2x faster</div>
                <div style="color:#666; font-size:0.7rem;">1T Plasma + 10M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-chart" onclick="Game.buyArtifact('chart')">FORGE</button>
        </div>

        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">VOID CRYSTAL</div>
                <div style="color:#aaa; font-size:0.7rem;">Void particles spawn 2x faster</div>
                <div style="color:#666; font-size:0.7rem;">5T Biomass + 50M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-crystal" onclick="Game.buyArtifact('crystal')">FORGE</button>
        </div>

        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">CHRONON AMPLIFIER</div>
                <div style="color:#aaa; font-size:0.7rem;">Chronon boost +25%</div>
                <div style="color:#666; font-size:0.7rem;">10T Aether + 100M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-amplifier" onclick="Game.buyArtifact('amplifier')">FORGE</button>
        </div>

        <div class="forge-item">
            <div>
                <div style="color:#fff; font-weight:bold; font-size:0.9rem;">INFINITY LOOP</div>
                <div style="color:#aaa; font-size:0.7rem;">Auto-buy upgrades 2x faster</div>
                <div style="color:#666; font-size:0.7rem;">50T Dark Matter + 500M Essence</div>
            </div>
            <button class="forge-btn" id="forge-btn-loop" onclick="Game.buyArtifact('loop')">FORGE</button>
        </div>

        <button class="toggle-btn" onclick="document.getElementById('forge-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="challenges-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px; color:#ffd700;">THE MULTIVERSE</div>
        <div style="text-align:center; color:#aaa; font-size:0.8rem; margin-bottom:10px;">Challenges coming soon...</div>
        <button class="toggle-btn" onclick="document.getElementById('challenges-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="profile-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px;">PROFILES</div>
        <div style="text-align:center; color:#aaa; font-size:0.8rem; margin-bottom:10px;">Switch between game states</div>
        <div id="profile-list"></div>
        <button class="toggle-btn" onclick="document.getElementById('profile-modal').classList.remove('open')">CLOSE</button>
    </div>

    <div id="autobuy-modal" class="modal">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:5px;">LAYER AUTO-BUY</div>
        <div style="text-align:center; color:#aaa; font-size:0.8rem; margin-bottom:10px;">Enable/Disable auto-buy per layer</div>
        <div id="autobuy-list"></div>
        <button class="toggle-btn" onclick="document.getElementById('autobuy-modal').classList.remove('open')">CLOSE</button>
    </div>

    <!-- SINGULARITY COLLAPSE MODAL -->
    <div id="singularity-modal" class="modal" style="display:none;">
        <div class="modal-content" style="max-width:900px; background:linear-gradient(135deg, rgba(10,0,30,0.98), rgba(30,0,50,0.98)); border:2px solid #bd00ff; box-shadow: 0 0 40px rgba(189,0,255,0.6);">
            <div style="position:relative; overflow:hidden;">
                <div class="modal-header" style="background:linear-gradient(135deg, #bd00ff, #8a00cc); padding:20px; text-align:center; position:relative;">
                    <h2 style="margin:0; font-family:'Orbitron'; font-size:1.8rem; color:#fff; text-shadow: 0 0 20px rgba(255,255,255,0.8); animation: text-glow 2s ease-in-out infinite;">‚öõÔ∏è SINGULARITY COLLAPSE</h2>
                    <div style="margin-top:10px; font-size:0.9rem; color:#fff; opacity:0.9;">Collapse the Singularity to earn Void Cores and transcend beyond</div>
                    <button class="close-btn" onclick="document.getElementById('singularity-modal').classList.remove('open')" style="position:absolute; top:10px; right:10px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); color:#fff; padding:8px 15px; border-radius:5px; cursor:pointer; font-size:1rem;">‚úï</button>
                </div>
                
                <div style="padding:25px;">
                    <!-- Singularity Points Display -->
                    <div style="background:rgba(189,0,255,0.1); border:2px solid #bd00ff; border-radius:10px; padding:20px; margin-bottom:20px; text-align:center; position:relative; overflow:hidden;">
                        <div style="position:absolute; top:0; left:0; right:0; bottom:0; background:linear-gradient(45deg, transparent, rgba(189,0,255,0.1), transparent); animation: shimmer 3s infinite;"></div>
                        <div style="font-size:0.9rem; color:#bd00ff; margin-bottom:8px; font-weight:bold;">VOID CORES</div>
                        <div id="singularity-points-display" style="font-size:2.5rem; font-family:'Orbitron'; color:#fff; text-shadow: 0 0 15px rgba(189,0,255,0.8); font-weight:bold;">0</div>
                        <div style="margin-top:10px; font-size:0.85rem; color:#aaa;">Maximum Essence Reached: <span id="max-essence-display" style="color:#bd00ff;">0</span></div>
                        <div style="margin-top:8px; font-size:0.85rem; color:#aaa;">Next Collapse: <span id="singularity-pending" style="color:#0ff;">+0 Void Cores</span></div>
                    </div>
                    
                    <!-- Prestige Button -->
                    <button id="singularity-prestige-btn" onclick="Game.doSingularityCollapse()" onmouseenter="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0 40px rgba(189,0,255,0.8)';" onmouseleave="this.style.transform='scale(1)'; this.style.boxShadow='0 0 30px rgba(189,0,255,0.5)';" style="width:100%; padding:20px; font-size:1.3rem; font-family:'Orbitron'; background:linear-gradient(135deg, #bd00ff, #8a00cc); border:2px solid #fff; color:#fff; border-radius:10px; cursor:pointer; margin-bottom:25px; font-weight:bold; text-transform:uppercase; letter-spacing:2px; box-shadow: 0 0 30px rgba(189,0,255,0.5); transition:all 0.3s; position:relative; overflow:hidden;" disabled>
                        <span style="position:relative; z-index:1;">COLLAPSE SINGULARITY</span>
                    </button>
                    
                    <!-- Upgrades Section -->
                    <div style="border-top:2px solid rgba(189,0,255,0.3); padding-top:20px;">
                        <div style="font-size:1.2rem; font-family:'Orbitron'; color:#bd00ff; margin-bottom:15px; text-align:center;">VOID CORE UPGRADES</div>
                        <div id="singularity-upgrades" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(300px, 1fr)); gap:15px;">
                            <!-- Upgrades will be generated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <div id="lore-box">
        <div class="lore-title">System Log</div>
        <div class="lore-text" id="lore-content">Initializing...</div>
    </div>

    <div id="particle-info" style="position:fixed; top:80px; left:20px; background:rgba(0,0,0,0.7); border:1px solid #bd00ff; padding:10px; border-radius:5px; z-index:50; display:none; color:#fff; font-family:'Share Tech Mono'; font-size:0.8rem; cursor:move; user-select:none;">
        <div style="color:#bd00ff; font-weight:bold; margin-bottom:5px;">PARTICLE RATES</div>
        <div id="void-particle-rate" style="color:#bd00ff;">Void: +0/s</div>
        <div id="cosmic-particle-rate" style="color:#0ff; margin-top:3px;">Cosmic: +0/s</div>
    </div>
    
    <button id="manual-btn" onclick="document.getElementById('manual-modal').classList.add('open')">üìñ</button>

    <div class="ui-layer">
        
        <div class="control-panel">
            <div class="header">
                <h1 id="game-title">CHRONO ENGINE</h1>
                
                <button id="warp-btn" onclick="Game.warpToInfinity()">
                    ‚àû WARP TO INFINITY ‚àû
                </button>
                
                <button id="return-btn" onclick="Game.returnToCircles()">
                    &lt;&lt; STABILIZE REALITY
                </button>

                <div id="circle-ui-group">
                    <div id="prestige-container">
                        <div class="prestige-box">
                            <div>
                                <div style="font-size:0.7rem; color:#888;">CHRONONS (Global +10% ea)</div>
                                <div class="chronon-display"><span id="chronon-val">0</span> CHRONONS</div>
                            </div>
                            <button class="prestige-btn" id="prestige-btn" onclick="Game.doPrestige()">REWIND TIME</button>
                        </div>
                        <button class="shop-open-btn" onclick="document.getElementById('shop-modal').classList.add('open'); UI.updateShopUI()">OPEN CHRONON SHOP</button>
                    </div>

                    <div class="mult-controls">
                        <button class="mult-btn active" onclick="UI.setBuy(1, this)">1x</button>
                        <button class="mult-btn" onclick="UI.setBuy(5, this)">5x</button>
                        <button class="mult-btn" onclick="UI.setBuy(10, this)">10x</button>
                        <button class="mult-btn" onclick="UI.setBuy(100, this)">100x</button>
                        <button class="mult-btn" onclick="UI.setBuy(-1, this)">MAX</button>
                    </div>

                    <div class="rpm-wrapper">
                        <div class="rpm-summary" onclick="UI.toggleRPM()">
                            <span style="font-family:'Orbitron'; font-size:1.1rem; color:#fff"><span id="rpm-display">0</span> RPM</span>
                            <span style="font-size:0.7rem; color:#666">SYSTEM VELOCITY ‚ñº</span>
                        </div>
                        <div class="rpm-list" id="rpm-list"></div>
                    </div>
                </div>
                
                <button class="forge-open-btn" id="forge-open-btn" onclick="document.getElementById('forge-modal').classList.add('open'); UI.updateForgeUI()">
                    ‚öíÔ∏è OPEN INFINITY FORGE
                </button>
                
                <button class="forge-open-btn" id="singularity-btn" onclick="UI.openSingularityModal()" style="display:none; background:linear-gradient(135deg, #bd00ff, #8a00cc); border-color:#bd00ff; color:#fff; animation: pulse-glow 2s ease-in-out infinite;">
                    ‚öõÔ∏è SINGULARITY COLLAPSE
                </button>
                
                <button class="forge-open-btn" id="challenges-open-btn" onclick="document.getElementById('challenges-modal').classList.add('open'); UI.buildChallenges()" style="display:none; background:linear-gradient(135deg, #ffd700, #ffaa00); border-color:#ffd700; color:#000;">
                    üåå THE MULTIVERSE
                </button>
            </div>
            <div class="scroll-area" id="upgrades"></div>
        </div>

        <div class="center-hud">
            <div class="shards-val" id="main-display-val">0</div>
            
            <div id="click-combo-container">
                <div class="combo-text" id="combo-text">CLICK COMBO: +0%</div>
                <div class="combo-bar"><div class="combo-fill" id="combo-fill"></div></div>
            </div>

            <div class="currency-select">
                <button class="curr-btn" id="main-display-name" onclick="UI.toggleCurrList()">TIME SHARDS ‚ñº</button>
                <div class="curr-list" id="curr-list">
                    </div>
            </div>
            
            <button id="reality-btn" onclick="Game.activateReality()">REALITY</button>
        </div>

        <div class="popup-area" id="popups"></div>
    </div>

    <button class="dev-toggle" onclick="document.getElementById('dev-menu').classList.toggle('open')">~</button>
    <div class="dev-menu" id="dev-menu">
        <div style="color:#f44; font-weight:bold; margin-bottom:5px; text-align:center;">DEV CONSOLE</div>
        <button class="dev-btn" onclick="Game.triggerEvent()">Force Event</button>
        <button class="dev-btn" onclick="Game.cheatMoney()">+1e30 Resources</button>
        <button class="dev-btn" onclick="Game.cheatSmall()">+1e6 Resources</button>
        <button class="dev-btn" onclick="Game.cheatSpeed()">+10% Speed</button>
        <button class="dev-btn" onclick="Game.unlockAll()">Unlock All Layers</button>
        <button class="dev-btn" onclick="Game.maxSpeed()">Set Speed to 1T</button>
        <button class="dev-btn" onclick="Game.chronons += 100; UI.updatePrestigeUI()">+100 Chronons</button>
        <button class="dev-btn" onclick="Game.reality.shards += 1e6; UI.updateMainDisplay()">+1M Reality Shards</button>
        <button class="dev-btn" onclick="Game.infinityPoints += 1e12; UI.updateMainDisplay()">+1T Essence</button>
        <button class="dev-btn" onclick="Game.rings.forEach((r, i) => { r.upgrades.speed = 20; r.upgrades.value = 20; r.upgrades.auto = 20; }); UI.buildUpgrades()">Max All Upgrades</button>
        <button class="dev-btn" onclick="Game.reality.upgrades.speed = 10; Game.reality.upgrades.value = 10; UI.buildUpgrades()">Max Reality Upgrades</button>
        <button class="dev-btn" onclick="Game.layerAutoBuy.fill(true); UI.buildUpgrades()">Enable All Auto-Buy</button>
        <button class="dev-btn" onclick="Game.hardWipe()">FORCE WIPE SAVE</button>
    </div>

    <script>
        /**
         * CHRONO-CYCLES v8.3 - CRITICAL FIXES
         */

        const CONFIG = {
            layers: [
                { name: "Entropy", currency: "Time Shards", icon: "‚è≥", color: "#bf5af2", unlockRPM: 3000, lore: "The spark. Kinetic force creates the initial Entropy needed for existence." },
                { name: "Biomass", currency: "Genetic Code", icon: "üß¨", color: "#64ffda", unlockRPM: 3000, lore: "Organic matter stabilizes within the Cosmic Aether." },
                { name: "Aether", currency: "Cosmic Essence", icon: "üí†", color: "#9b4dca", unlockRPM: 3000, lore: "Matter dissolves into pure energy. The Cosmic Aether flows freely." },
                { name: "Plasma", currency: "Ionized Gas", icon: "‚ö°", color: "#ff6b9d", unlockRPM: 3000, lore: "Superheated matter achieves stellar ignition. Plasma arcs detect." },
                { name: "Dark Matter", currency: "Void Mass", icon: "üåë", color: "#8800ff", unlockRPM: 3000, lore: "Invisible mass detected. Dark Matter binds the galaxy together." },
                { name: "Quantum", currency: "Q-Bits", icon: "‚öõÔ∏è", color: "#00ffff", unlockRPM: 3000, lore: "Sub-atomic breakdown. Entanglement established across space-time." },
                { name: "Exotic", currency: "Strange Matter", icon: "üßø", color: "#ff00ff", unlockRPM: 3000, lore: "Physics breaking down. Exotic particles defying gravity." },
                { name: "Chronos", currency: "Seconds", icon: "üï∞Ô∏è", color: "#ffffff", unlockRPM: 3000, lore: "Time dilation active. We are harvesting raw time." },
                { name: "Event Horizon", currency: "Hawking Radiation", icon: "üï≥Ô∏è", color: "#444444", unlockRPM: 3000, lore: "Approaching the point of no return. Light cannot escape." },
                { name: "Singularity", currency: "Zero-Point Energy", icon: "üåå", color: "#000000", unlockRPM: 3000, lore: "Infinite density achieved. The Dimension Warp is ready." }
            ],
            realityLayers: [
                { name: "Reality", currency: "Reality Shards", icon: "üëÅÔ∏è", color: "#ffd700", lore: "The Universe is merely fuel for the machine." }
            ],
            challenges: [
                {
                    id: 'frictionless',
                    name: 'The Frictionless Void',
                    desc: 'Friction is 0, but Torque is capped at 1. Can you reach Infinity?',
                    reward: 'Torque Multiplier +20%',
                    rewardType: 'torqueMultiplier',
                    rewardValue: 0.20,
                    condition: (game) => game.infinityPoints >= 1e12
                },
                {
                    id: 'entropy',
                    name: 'Entropy Only',
                    desc: 'Only the first ring works. The other 9 are broken.',
                    reward: 'Shard Multiplier +30%',
                    rewardType: 'shardMultiplier',
                    rewardValue: 0.30,
                    condition: (game) => game.rings[0] && game.rings[0].velocity >= 100000
                },
                {
                    id: 'reverse',
                    name: 'Reverse Polarity',
                    desc: 'All rings spin backwards. Resources only generate on negative RPM.',
                    reward: 'Speed Boost +20%',
                    rewardType: 'speedBoost',
                    rewardValue: 0.20,
                    condition: (game) => game.rings.every(r => r.velocity <= -1000)
                }
            ],
            baseRadius: 60,
            spacing: 35,
            friction: 2.0,
            clickTorque: 0.7, 
            redTorque: 0.35,     
            maxTorque: 1e15, 
            visualRPMCap: 3000
        };

        const AudioSys = {
            ctx: null,
            masterGain: null, sfxGain: null, masterVol: 0.5, sfxVol: 0.5, muteTicks: false,

            init() {
                if (!this.ctx) {
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                        this.masterGain = this.ctx.createGain(); 
                        this.sfxGain = this.ctx.createGain();
                        this.masterGain.gain.value = this.masterVol; 
                        this.sfxGain.gain.value = this.sfxVol;
                        this.masterGain.connect(this.ctx.destination); 
                        this.sfxGain.connect(this.masterGain);
                    } catch(e) { console.error("Audio Init Failed", e); }
                }
                if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },
            setMaster(val) { this.masterVol = val / 100; if(this.masterGain) this.masterGain.gain.value = this.masterVol; },
            setSFX(val) { this.sfxVol = val / 100; if(this.sfxGain) this.sfxGain.gain.value = this.sfxVol; },
            toggleTicks() {
                this.muteTicks = !this.muteTicks;
                document.getElementById('mute-ticks-btn').innerText = `MUTE TICKS: ${this.muteTicks ? "ON" : "OFF"}`;
                document.getElementById('mute-ticks-btn').classList.toggle('active');
            },
            playTick(layer) {
                if(this.muteTicks || !this.ctx) return;
                try {
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(400 - (layer * 30), t); osc.type = 'sine';
                    gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.03); 
                    osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.03);
                } catch(e) {}
            },
            playWarp() {
                // Max Speed Sound (Sawtooth) - FADE OUT UPDATE
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(1000, t + 2);
                
                // Fade out logic: Start vol 0.11 -> 0 over 2 seconds
                gain.gain.setValueAtTime(0.11, t); 
                gain.gain.linearRampToValueAtTime(0, t + 2.0);
                
                osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 2.0);
            },
            playTeleport() {
                // Dimension Shift Sound (Heavy Implosion)
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'square'; 
                osc.frequency.setValueAtTime(50, t); 
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.2); 
                osc.frequency.exponentialRampToValueAtTime(10, t + 1.5); 
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 1.5);
            },
            playUnlock() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(110, t); osc.frequency.exponentialRampToValueAtTime(880, t + 0.6);
                gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                const drone = this.ctx.createOscillator(); const droneGain = this.ctx.createGain();
                drone.type = 'triangle'; drone.frequency.setValueAtTime(55, t);
                droneGain.gain.setValueAtTime(0.1, t); droneGain.gain.setValueAtTime(0.1, t + 1.5); droneGain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); 
                osc.connect(gain); gain.connect(this.sfxGain); drone.connect(droneGain); droneGain.connect(this.sfxGain);
                osc.start(t); osc.stop(t + 0.6); drone.start(t); drone.stop(t + 2.0);
            }
        };

        const Game = {
            dimension: 0, resources: new Array(10).fill(0), rings: [], unlockedLayers: 1, selectedRes: 0, selectedRPM: 0, 
            lastTime: performance.now(), buyAmount: 1, chronons: 0, infinityPoints: 0,
            singularityPoints: 0, maxEssenceReached: 0, // Singularity Collapse prestige
            singularityUpgrades: { resonance: 0, efficiency: 0, density: 0, cascade: 0 }, // Prestige upgrades 
            autoBuyEnabled: true,
            layerAutoBuy: new Array(10).fill(false),
            layerAutoBuyPurchased: new Array(10).fill(false), // Track if auto-buy was purchased
            floatersEnabled: new Array(10).fill(true),
            
            // v8.0 Reality Vars
            reality: {
                shards: 0,
                rings: [], 
                upgrades: { speed: 0, value: 0 }
            },
            profiles: {
                main: null,
                challenges: {}
            },
            currentProfile: 'main',
            artifacts: { prism: false, anchor: false, chart: false },
            
            settings: { floaters: true, autoSelectMaterial: false },
            hasAutoDisabledFloaters: false,
            disableScheduled: false,
            _isResetting: false,

            // CLICK COMBO
            clickCombo: 0,
            layerClickCombo: new Array(11).fill(0), // Per-layer click combo (0-9 for rings, 10 for reality ring)
            blackHoleCombo: 0, // Blackhole click combo 
            comboGrace: 0,

            // GLOBAL EVENT SYSTEM
            activeEvent: null, eventTimer: 0, nextEventTime: 90,

            // INFINITY STATE
            blackHoleSize: 10, blackHoleMass: 0, infUpgrades: { weave: 0, void: 0, particles: 0, clickGain: 0 },
            cosmicParticles: [],
            voidParticles: [],
            _essenceGainHistory: [], // Track essence gains for rate calculation 

            // OFFLINE PROGRESS
            hiddenTime: null,
            // SOUND TRACKING
            hasPlayedMaxSound: new Array(10).fill(false),

            init() {
                this.resetRings(); 
                this.initRealityRings();
                this.load(); 
                this.validateState();
                UI.init(); Renderer.init();
                UI.setLore("The Singularity is dormant. Strike the Core to generate Entropy.");
                this.loop();
                setInterval(() => this.save(), 30000);
                window.addEventListener('mousedown', (e) => {
                    AudioSys.init();
                    if(e.target.tagName === 'CANVAS') {
                        if(this.dimension === 0 || this.dimension === 2) this.handleCircleClick(e);
                        else if(this.dimension === 1) this.handleInfinityClick(e);
                    }
                });
                window.addEventListener('keydown', (e) => { if(e.key === '`' || e.key === '~') document.getElementById('dev-menu').classList.toggle('open'); });
                
                // DRAGGABLE PARTICLE INFO
                let particleInfoDragging = false;
                let particleInfoOffset = { x: 0, y: 0 };
                const particleInfo = document.getElementById('particle-info');
                if(particleInfo) {
                    particleInfo.addEventListener('mousedown', (e) => {
                        particleInfoDragging = true;
                        const rect = particleInfo.getBoundingClientRect();
                        particleInfoOffset.x = e.clientX - rect.left;
                        particleInfoOffset.y = e.clientY - rect.top;
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    document.addEventListener('mousemove', (e) => {
                        if(particleInfoDragging && particleInfo) {
                            particleInfo.style.left = (e.clientX - particleInfoOffset.x) + 'px';
                            particleInfo.style.top = (e.clientY - particleInfoOffset.y) + 'px';
                            particleInfo.style.right = 'auto';
                            particleInfo.style.bottom = 'auto';
                        }
                    });
                    document.addEventListener('mouseup', () => {
                        particleInfoDragging = false;
                    });
                }
                
                // TOUCH SUPPORT for mobile
                window.addEventListener('touchstart', (e) => {
                    AudioSys.init();
                    if(e.target.tagName === 'CANVAS' && e.touches.length > 0) {
                        e.preventDefault(); // Prevent scroll/zoom
                        const touch = e.touches[0];
                        const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                        if(this.dimension === 0 || this.dimension === 2) this.handleCircleClick(fakeEvent);
                        else if(this.dimension === 1) this.handleInfinityClick(fakeEvent);
                    }
                }, { passive: false });
            },
            
            validateState() {
                this.resources = this.resources.map(r => isNaN(r) ? 0 : r);
                this.rings.forEach(r => {
                    if(isNaN(r.velocity)) r.velocity = 0;
                    if(isNaN(r.torque)) r.torque = 0;
                    if(isNaN(r.angle)) r.angle = 0;
                });
                // Ensure array lengths match config
                if(this.layerAutoBuy.length < 10) this.layerAutoBuy = new Array(10).fill(false);
                if(this.layerAutoBuyPurchased.length < 10) this.layerAutoBuyPurchased = new Array(10).fill(false);
                if(this.floatersEnabled.length < 10) this.floatersEnabled = new Array(10).fill(true);
            },

            handleCircleClick(e) {
                // Account for camera transform
                const screenX = e.clientX;
                const screenY = e.clientY;
                const worldX = (screenX - Renderer.cx - Renderer.cameraX) / Renderer.zoom;
                const worldY = (screenY - Renderer.cy - Renderer.cameraY) / Renderer.zoom;
                const dx = worldX; const dy = worldY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Scale click detection for Reality mode
                let clickRadiusMult = 1;
                if(this.dimension === 2) clickRadiusMult = 0.15; // Tiny target in center

                let clickedLayer = -1;
                for(let i=0; i<this.unlockedLayers; i++) {
                    const r = (CONFIG.baseRadius + (i * CONFIG.spacing)) * clickRadiusMult;
                    if(Math.abs(dist - r) < (20 * clickRadiusMult)) { clickedLayer = i; break; }
                }

                if(this.dimension === 2 && clickedLayer === -1) {
                    // Reality ring click detection
                    const realityRadius = (CONFIG.baseRadius + 90); // Same as drawRealityRings
                    if(Math.abs(dist - realityRadius) < 25) {
                        // Clicked on Reality ring - add torque with click combo
                        // Use layer combo index 10 for reality ring
                        this.layerClickCombo = this.layerClickCombo || new Array(11).fill(0);
                        this.layerClickCombo[10] = (this.layerClickCombo[10] || 0) + 0.005;
                        // Reality ring combo - doesn't use Event Horizon (that's for blackhole)
                        let maxCombo = 0.5;
                        if(this.layerClickCombo[10] > maxCombo) this.layerClickCombo[10] = maxCombo;
                        this.layerComboGrace = this.layerComboGrace || new Array(11).fill(0);
                        this.layerComboGrace[10] = 0.25;
                        
                        const baseTorque = CONFIG.clickTorque * 0.3; // 30% of normal click torque
                        const comboBoost = 1 + this.layerClickCombo[10];
                        const realityTorque = baseTorque * comboBoost;
                        
                        if(this.reality.rings[0]) {
                            this.reality.rings[0].torque += realityTorque;
                            Renderer.clickEffect(e.clientX, e.clientY, CONFIG.realityLayers[0].color);
                            AudioSys.playTick(10);
                            UI.updateComboUI();
                        }
                        return; // Don't process as inner ring click
                    }
                }

                if(clickedLayer === -1 && dist < 100 * clickRadiusMult) clickedLayer = 0;
                
                if(clickedLayer !== -1) {
                    let layerIdx = clickedLayer;
                    let base = (layerIdx === 0) ? CONFIG.redTorque : CONFIG.clickTorque;
                    
                    // Per-layer click combo (only for this specific ring)
                    this.layerClickCombo = this.layerClickCombo || new Array(11).fill(0);
                    this.layerClickCombo[layerIdx] = (this.layerClickCombo[layerIdx] || 0) + 0.005; 
                    // Ring combos - don't use Event Horizon (that's for blackhole)
                    let maxCombo = 0.5; 
                    if(this.layerClickCombo[layerIdx] > maxCombo) this.layerClickCombo[layerIdx] = maxCombo; 
                    this.layerComboGrace = this.layerComboGrace || new Array(11).fill(0);
                    this.layerComboGrace[layerIdx] = 0.25; 
                    
                    const layerComboBoost = 1 + this.layerClickCombo[layerIdx];
                    
                    if(this.dimension === 0) UI.spawnComboText(`+${(this.layerClickCombo[layerIdx] * 100).toFixed(1)}%`, e.clientX, e.clientY);

                    // Auto-select material if setting enabled
                    if(this.settings.autoSelectMaterial) {
                        UI.selectCurr(layerIdx);
                    }

                    let boost = (this.rings[layerIdx].upgrades.auto * 5) + (base * 100) * layerComboBoost; 
                    if (this.activeEvent && this.activeEvent.name === "KINETIC FRENZY") boost += this.rings[layerIdx].velocity * 0.05; 
                    this.rings[layerIdx].velocity += boost;

                    Renderer.clickEffect(e.clientX, e.clientY, CONFIG.layers[layerIdx].color);
                    UI.updateComboUI();
                }
            },

            handleInfinityClick(e) {
                // Account for camera transform
                const screenX = e.clientX;
                const screenY = e.clientY;
                const worldX = (screenX - Renderer.cx - Renderer.cameraX) / Renderer.zoom;
                const worldY = (screenY - Renderer.cy - Renderer.cameraY) / Renderer.zoom;
                const dx = worldX; const dy = worldY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < this.blackHoleSize + 20) {
                    // Click combo for blackhole - max increases with Event Horizon upgrade
                    this.blackHoleCombo = (this.blackHoleCombo || 0) + 0.005;
                    const maxCombo = 0.5 + (this.infUpgrades.weave * 0.05); // Event Horizon increases blackhole combo max
                    if(this.blackHoleCombo > maxCombo) this.blackHoleCombo = maxCombo;
                    this.blackHoleComboGrace = 0.25;
                    
                    const comboBoost = 1 + this.blackHoleCombo;
                    const clickMult = Math.pow(1.5, this.infUpgrades.clickGain || 0); // Infinity upgrade (x1.5 per level, multiplicative)
                    const eventMult = this.eventEssenceMult || 1;
                    const totalGain = 1 * clickMult * comboBoost * eventMult;
                    
                    this.blackHoleMass += 1;
                    // Grow slower: use log base 1.5, and increase max size to 5x (6750 instead of 1350)
                    if(this.blackHoleSize < 6750) {
                        // Slower growth: using log base 1.5 makes it grow slower
                        this.blackHoleSize = 10 + Math.log(this.blackHoleMass + 1) / Math.log(1.5) * 10;
                    }
                    this.infinityPoints += totalGain;
                    // Track gain for rate calculation
                    this._essenceGainHistory = this._essenceGainHistory || [];
                    this._essenceGainHistory.push({ amount: totalGain, time: performance.now(), source: 'click' });
                    // Keep only last 2 seconds
                    this._essenceGainHistory = this._essenceGainHistory.filter(h => performance.now() - h.time < 2000);
                    UI.spawnText(`+${totalGain.toFixed(1)} Essence`, 0, true, 'blue-purple');
                    UI.spawnComboText(`+${(this.blackHoleCombo * 100).toFixed(1)}%`, e.clientX, e.clientY);
                    Renderer.clickEffect(e.clientX, e.clientY, '#bd00ff');
                    UI.updateMainDisplay();
                    UI.updateComboUI();
                }
            },

            resetRings() {
                this.rings = [];
                for(let i=0; i<CONFIG.layers.length; i++) {
                    this.rings.push({
                        angle: 0, velocity: 0, torque: 0,
                        upgrades: { speed: 0, value: 0, auto: 0 },
                        baseVal: Math.pow(8, i), solidTime: 0, prestigeLevel: 0
                    });
                }
            },
            
            initRealityRings() {
                this.reality.rings = [{
                    angle: 0, velocity: 0, torque: 0
                }];
                if(!this.reality.upgrades) this.reality.upgrades = { speed: 0, value: 0 };
                if(!this.reality.completedChallenges) this.reality.completedChallenges = [];
                if(!this.reality.universalConstants) this.reality.universalConstants = { torqueMultiplier: 0, shardMultiplier: 0, frictionReduction: 0, speedBoost: 0 };
            },

            warpToInfinity() {
                const load = document.getElementById('loading-screen'); load.style.display = 'flex';
                setTimeout(() => load.style.opacity = 1, 10); AudioSys.playTeleport(); 
                setTimeout(() => {
                    this.dimension = 1; 
                    UI.setLore("DIMENSION: INFINITY. STRUCTURE: STABLE. BEGIN.");
                    document.getElementById('warp-btn').style.display = 'none';
                    document.getElementById('return-btn').style.display = 'block';
                    document.getElementById('circle-ui-group').style.display = 'none';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('forge-open-btn').style.display = 'block';
                    
                    UI.buildInfinityUpgrades();
                    
                    document.getElementById('main-display-name').innerText = "INFINITY ESSENCE";
                    document.getElementById('main-display-name').style.color = "#bd00ff";
                    document.getElementById('main-display-val').style.color = "#bd00ff";
                    document.getElementById('main-display-val').innerText = Format(this.infinityPoints);
                    document.querySelector('.currency-select').style.pointerEvents = "none";
                    UI.updateComboUI();
                    // Show Singularity button if enough essence
                    const singularityBtn = document.getElementById('singularity-btn');
                    if(singularityBtn) {
                        const hasEnough = (this.maxEssenceReached >= 1e8) || (this.infinityPoints >= 1e8);
                        if(hasEnough) {
                            singularityBtn.style.display = 'block';
                        }
                    }
                    load.style.opacity = 0; setTimeout(() => load.style.display = 'none', 1000);
                }, 3000);
            },

            activateReality() {
                if(this.infinityPoints < 1e12 && !Game.artifacts.prism) return; 
                
                const load = document.getElementById('loading-screen');
                document.querySelector('.loader-text').innerText = "FRACTURING REALITY";
                load.style.display = 'flex'; 
                setTimeout(() => load.style.opacity = 1, 10); 
                AudioSys.playTeleport();
                
                setTimeout(() => {
                    this.dimension = 2; // REALITY MODE
                    UI.setLore("REALITY FRACTURED. Use the inner engine to power the outer ring.");
                    document.getElementById('return-btn').style.display = 'block';
                    document.getElementById('return-btn').innerText = "<< RETURN TO MICROCOSM";
                    document.getElementById('circle-ui-group').style.display = 'block'; 
                    document.querySelector('.currency-select').style.pointerEvents = "auto";
                    
                    // Hide Reality Button
                    document.getElementById('reality-btn').style.display = 'none';
                    document.getElementById('forge-open-btn').style.display = 'none';
                    document.getElementById('challenges-open-btn').style.display = 'block';
                    document.getElementById('profile-btn').style.display = 'block';
                    document.getElementById('click-combo-container').style.display = 'block';
                    
                    document.getElementById('game-title').innerText = "REALITY ENGINE";
                    document.getElementById('game-title').style.color = "#ffd700";

                    UI.buildUpgrades(); // Will build Reality Upgrades now
                    UI.updateRPMList(); 
                    UI.updateCurrList(); 
                    UI.updateComboUI();
                    
                    // Switch to Reality Shards display
                    UI.selectCurr(10); 

                    load.style.opacity = 0; setTimeout(() => load.style.display = 'none', 1000);
                }, 3000);
            },

            returnToCircles() {
                const load = document.getElementById('loading-screen');
                document.querySelector('.loader-text').innerText = "STABILIZING REALITY";
                load.style.display = 'flex'; setTimeout(() => load.style.opacity = 1, 10); AudioSys.playTeleport();
                setTimeout(() => {
                    this.dimension = 0;
                    UI.setLore("Reality stabilized. Cycle restart.");
                    document.getElementById('return-btn').style.display = 'none';
                    document.getElementById('circle-ui-group').style.display = 'block';
                    document.querySelector('.currency-select').style.pointerEvents = "auto";
                    document.getElementById('forge-open-btn').style.display = 'none';
                    document.getElementById('particle-info').style.display = 'none';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('game-title').innerText = "CHRONO ENGINE";
                    document.getElementById('game-title').style.color = "#fff";
                    
                    // Show buttons if unlocked
                    if(this.unlockedLayers >= 10 || (this.infinityPoints >= 1e12 || this.artifacts.prism)) {
                        document.getElementById('warp-btn').style.display = 'block';
                    }
                    if(this.infinityPoints >= 1e12 || this.artifacts.prism) {
                        document.getElementById('reality-btn').style.display = 'block';
                    }
                    
                    UI.buildUpgrades(); UI.updateRPMList(); UI.updateCurrList(); UI.selectCurr(0);
                    UI.updatePrestigeUI();
                    UI.updateDimensionUI();
                    UI.updateComboUI();
                    load.style.opacity = 0; setTimeout(() => load.style.display = 'none', 1000);
                }, 3000);
            },

            getTotalValue() {
                let total = 0;
                // Calculate from all layers, not just first
                for(let i=0; i<this.unlockedLayers; i++) {
                    total += this.resources[i] * Math.pow(10, i); 
                }
                return total;
            },

            doPrestige() {
                const totalVal = this.getTotalValue();
                // Exponential Chronon calculation: log10 of value/50000, multiplied by 10
                // This makes it much harder to get Chronons as values increase
                let pending = Math.floor(Math.log10(Math.max(1, totalVal / 50000)) * 3.14159);
                // Apply event multiplier if active
                if(this.eventChrononMult && this.eventChrononMult > 1) {
                    pending = Math.floor(pending * this.eventChrononMult);
                }
                
                if(totalVal < 50000) return;

                if(confirm(`HARD RESET REWIND? You will lose ALL upgrades, layers, and purify levels. You will gain ${pending} Chronons.`)) {
                    // CRITICAL FIX: Update Chronons BEFORE resetting
                    this.chronons += pending; 
                    this.resources.fill(0); 
                    this.unlockedLayers = 1;
                    
                    this.resetRings(); 
                    this.selectedRes = 0;
                    this.save(); 

                    UI.buildUpgrades(); 
                    UI.updateCurrList();
                    UI.selectCurr(0);
                    UI.updateRPMList(); 

                    UI.setLore("Time has been rewritten. The cycles are stronger.");
                    Achievements.show("TEMPORAL REWRITE", `Gained ${pending} Chronons.`, "#4488ff");
                    Achievements.unlock("prestige");
                    document.getElementById('warp-btn').style.display = 'none';
                    
                    if (this.hasAutoDisabledFloaters) {
                        this.settings.floaters = true;
                        this.hasAutoDisabledFloaters = false;
                        this.disableScheduled = false;
                        UI.toggleFloaters(); 
                        document.getElementById('settings-hint').style.display = 'none';
                    }

                    UI.updatePrestigeUI();
                }
            },

            doSingularityCollapse() {
                // Only available in Infinity dimension
                if(this.dimension !== 1) return;
                
                // Require at least 1 billion essence to prestige (check current or max reached)
                const currentMax = Math.max(this.maxEssenceReached || 0, this.infinityPoints || 0);
                if(currentMax < 1e9) {
                    alert(`You need at least 1 billion Essence to collapse the Singularity. Current: ${Format(this.infinityPoints)}`);
                    return;
                }
                
                // Calculate Void Cores: log10(maxEssence / 1e9) * multiplier
                // Similar to Chronons but for Infinity
                // Fix: Ensure at least 1 core if you have 1e9 or more
                const essenceRatio = currentMax / 1e9;
                let voidCores = 0;
                if(essenceRatio >= 1) {
                    voidCores = Math.max(1, Math.floor(Math.log10(essenceRatio) * 2.5) + 1);
                }
                
                if(confirm(`COLLAPSE SINGULARITY? You will lose ALL Infinity upgrades and Essence. You will gain ${voidCores} Void Cores. Continue?`)) {
                    // Add Void Cores BEFORE reset
                    this.singularityPoints += voidCores;
                    
                    // Reset Infinity state
                    this.infinityPoints = 0;
                    this.maxEssenceReached = 0;
                    this.infUpgrades = { weave: 0, void: 0, particles: 0, clickGain: 0 };
                    this.cosmicParticles = [];
                    this.voidParticles = [];
                    this.blackHoleSize = 10;
                    this.blackHoleMass = 0;
                    this.blackHoleCombo = 0;
                    
                    this.save();
                    UI.buildInfinityUpgrades();
                    UI.updateSingularityUI();
                    UI.updateMainDisplay();
                    
                    // Close modal after collapse
                    const modal = document.getElementById('singularity-modal');
                    if(modal) modal.classList.remove('open');
                    
                    Achievements.show("SINGULARITY COLLAPSED", `Gained ${voidCores} Void Cores!`, "#bd00ff");
                }
            },

            overclockLayer(idx) {
                if(confirm(`Purify ${CONFIG.layers[idx].name}? Resets upgrades AND currency but grants +50% Multiplier.`)) {
                    this.rings[idx].upgrades.speed = 0;
                    this.rings[idx].upgrades.value = 0;
                    this.rings[idx].upgrades.auto = 0;
                    this.rings[idx].prestigeLevel++;
                    this.rings[idx].torque = 0;
                    this.rings[idx].velocity = 0;
                    this.resources[idx] = 0; 
                    UI.buildUpgrades();
                    Achievements.show("LAYER PURIFIED", `${CONFIG.layers[idx].name} Overclocked x${this.rings[idx].prestigeLevel}`, CONFIG.layers[idx].color);
                }
            },

            buyShopItem(layerIdx) {
                const cost = layerIdx + 1;
                if(this.chronons >= cost && !this.layerAutoBuy[layerIdx]) {
                    this.chronons -= cost;
                    this.layerAutoBuy[layerIdx] = true;
                    UI.updateShopUI();
                    UI.updatePrestigeUI();
                }
            },
            toggleLayerAutoBuy(idx) {
                if(!this.layerAutoBuy[idx]) {
                    // Need to purchase first if not already purchased
                    if(!this.layerAutoBuyPurchased[idx]) {
                        const cost = Math.floor((idx + 1) * Math.pow(2.5, idx));
                        if(this.chronons >= cost) {
                            this.chronons -= cost;
                            this.layerAutoBuyPurchased[idx] = true;
                            this.layerAutoBuy[idx] = true;
                            UI.updateShopUI();
                            UI.updatePrestigeUI();
                            UI.buildAutoBuyMenu();
                            UI.buildUpgrades();
                        }
                    } else {
                        // Already purchased, just toggle on
                        this.layerAutoBuy[idx] = true;
                        UI.buildAutoBuyMenu();
                        UI.buildUpgrades();
                    }
                } else {
                    // Just toggle off (doesn't lose purchase)
                    this.layerAutoBuy[idx] = false;
                    UI.buildAutoBuyMenu();
                    UI.buildUpgrades();
                }
            },
            saveProfile(profileName) {
                // Save current game state to a profile
                this.profiles[profileName] = {
                    resources: [...this.resources],
                    rings: JSON.parse(JSON.stringify(this.rings)),
                    reality: JSON.parse(JSON.stringify(this.reality)),
                    dimension: this.dimension,
                    unlockedLayers: this.unlockedLayers,
                    chronons: this.chronons,
                    infinityPoints: this.infinityPoints,
                    artifacts: {...this.artifacts},
                    layerAutoBuy: [...this.layerAutoBuy],
                    floatersEnabled: [...this.floatersEnabled],
                    selectedRPM: this.selectedRPM
                };
            },
            loadProfile(profileName) {
                if(!this.profiles[profileName]) return false;
                const profile = this.profiles[profileName];
                this.resources = profile.resources ? [...profile.resources] : new Array(10).fill(0);
                this.rings = profile.rings ? JSON.parse(JSON.stringify(profile.rings)) : [];
                this.reality = profile.reality ? JSON.parse(JSON.stringify(profile.reality)) : { shards: 0, rings: [], upgrades: { speed: 0, value: 0 } };
                this.dimension = profile.dimension !== undefined ? profile.dimension : 0;
                this.unlockedLayers = profile.unlockedLayers !== undefined ? profile.unlockedLayers : 1;
                this.chronons = profile.chronons !== undefined ? profile.chronons : 0;
                this.infinityPoints = profile.infinityPoints !== undefined ? profile.infinityPoints : 0;
                this.artifacts = profile.artifacts ? {...profile.artifacts} : { prism: false, anchor: false, chart: false, crystal: false, amplifier: false, loop: false };
                // Ensure all artifact properties exist
                if(!this.artifacts.crystal) this.artifacts.crystal = false;
                if(!this.artifacts.amplifier) this.artifacts.amplifier = false;
                if(!this.artifacts.loop) this.artifacts.loop = false;
                this.layerAutoBuy = profile.layerAutoBuy ? [...profile.layerAutoBuy] : new Array(10).fill(false);
                this.layerAutoBuyPurchased = profile.layerAutoBuyPurchased ? [...profile.layerAutoBuyPurchased] : new Array(10).fill(false);
                this.floatersEnabled = profile.floatersEnabled ? [...profile.floatersEnabled] : new Array(10).fill(true);
                this.selectedRPM = profile.selectedRPM !== undefined ? profile.selectedRPM : 0;
                this.blackHoleSize = profile.blackHoleSize !== undefined ? profile.blackHoleSize : 10;
                this.blackHoleMass = profile.blackHoleMass !== undefined ? profile.blackHoleMass : 0;
                this.infUpgrades = profile.infUpgrades ? JSON.parse(JSON.stringify(profile.infUpgrades)) : { weave: 0, void: 0, particles: 0 };
                if(!this.infUpgrades.particles) this.infUpgrades.particles = 0;
                this.currentProfile = profileName;
                
                // Ensure rings are properly initialized
                if(!this.rings || this.rings.length === 0) {
                    this.resetRings();
                }
                
                // Ensure reality rings are initialized
                if(!this.reality.rings || this.reality.rings.length === 0) {
                    this.initRealityRings();
                }
                
                // Reset event flags to prevent bugs
                this.eventMult = 1;
                this.eventSpeed = 1;
                this.eventFriction = 1;
                this._challengeFriction = undefined;
                this._challengeMaxTorque = undefined;
                this._challengeClickTorque = undefined;
                
                // Update UI
                UI.buildUpgrades();
                UI.updateRPMList();
                UI.updateCurrList();
                UI.updateMainDisplay();
                UI.updatePrestigeUI();
                UI.updateChallengeInfo();
                UI.updateDimensionUI();
                return true;
            },
            
            buyArtifact(item) {
                let costShards = 0, costEssence = 0, resType = -1; 
                
                if (item === 'prism') { costShards = 1e12; costEssence = 1e6; resType = 0; } 
                if (item === 'anchor') { costShards = 1e12; costEssence = 5e6; resType = 4; } 
                if (item === 'chart') { costShards = 1e12; costEssence = 10e6; resType = 3; }
                if (item === 'crystal') { costShards = 5e12; costEssence = 50e6; resType = 1; }
                if (item === 'amplifier') { costShards = 10e12; costEssence = 100e6; resType = 2; }
                if (item === 'loop') { costShards = 50e12; costEssence = 500e6; resType = 5; } 
                
                if (this.resources[resType] >= costShards && this.infinityPoints >= costEssence && !this.artifacts[item]) {
                    this.resources[resType] -= costShards;
                    this.infinityPoints -= costEssence;
                    this.artifacts[item] = true;
                    UI.updateForgeUI();
                    UI.updateMainDisplay();
                    Achievements.show("ARTIFACT FORGED", "Permanent upgrade acquired.", "#bd00ff");
                }
            },
            
            buyRealityUpgrade(type) {
                let level = this.reality.upgrades[type];
                let cost = 10 * Math.pow(2.5, level);
                if(this.reality.shards >= cost) {
                    this.reality.shards -= cost;
                    this.reality.upgrades[type]++;
                    UI.buildUpgrades(); // Rebuild to update cost/level
                    UI.updateMainDisplay();
                }
            },
            
            activateChallenge(challengeId) {
                const challenge = CONFIG.challenges.find(c => c.id === challengeId);
                if(!challenge) return;
                
                // Close modal first
                document.getElementById('challenges-modal').classList.remove('open');
                
                // Cool animation - flash effect
                const flash = document.getElementById('flash-overlay');
                flash.style.opacity = 0.8;
                flash.style.backgroundColor = '#ffd700';
                AudioSys.playTeleport();
                
                setTimeout(() => {
                    // Save current state to main profile
                    if(this.currentProfile === 'main') {
                        this.profiles.main = {
                            resources: JSON.parse(JSON.stringify(this.resources)),
                            rings: JSON.parse(JSON.stringify(this.rings)),
                            unlockedLayers: this.unlockedLayers,
                            chronons: this.chronons,
                            infinityPoints: this.infinityPoints,
                            reality: JSON.parse(JSON.stringify(this.reality)),
                            blackHoleSize: this.blackHoleSize,
                            blackHoleMass: this.blackHoleMass,
                            infUpgrades: JSON.parse(JSON.stringify(this.infUpgrades))
                        };
                    }
                    
                    // Create challenge profile - fresh start
                    const profileId = `challenge_${challengeId}`;
                    this.profiles[profileId] = {
                        resources: new Array(10).fill(0),
                        rings: CONFIG.layers.map((_, i) => ({
                            velocity: 0, 
                            torque: 0, 
                            angle: 0, 
                            upgrades: { speed: 0, value: 0, auto: 0 }, 
                            prestigeLevel: 0, 
                            baseVal: Math.pow(8, i),
                            solidTime: 0
                        })),
                        unlockedLayers: 1,
                        dimension: 0,
                        chronons: 0,
                        infinityPoints: 0,
                        reality: {
                            shards: 0,
                            rings: [{ velocity: 0, torque: 0, angle: 0 }],
                            upgrades: { speed: 0, value: 0 },
                            activeChallenge: challengeId,
                            completedChallenges: [],
                            universalConstants: { torqueMultiplier: 0, shardMultiplier: 0, frictionReduction: 0, speedBoost: 0 }
                        },
                        blackHoleSize: 10,
                        blackHoleMass: 0,
                        infUpgrades: { weave: 0, void: 0, particles: 0 },
                        artifacts: { prism: false, anchor: false, chart: false },
                        layerAutoBuy: new Array(10).fill(false),
                        layerAutoBuyPurchased: new Array(10).fill(false),
                        floatersEnabled: new Array(10).fill(true),
                        selectedRPM: 0
                    };
                    
                    // Switch to challenge profile
                    this.currentProfile = profileId;
                    this.loadProfile(profileId);
                    
                    // Change selected currency to Entropy layer (0)
                    this.selectedRPM = 0;
                    UI.selectCurr(0);
                    
                    // Save the new profile
                    this.save();
                    
                    // Return to microcosm
                    this.dimension = 0;
                    document.getElementById('return-btn').style.display = 'none';
                    document.getElementById('reality-btn').style.display = 'none';
                    document.getElementById('forge-open-btn').style.display = 'none';
                    document.getElementById('challenges-open-btn').style.display = 'none';
                    document.getElementById('profile-btn').style.display = 'block';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('game-title').innerText = "CHRONO ENGINE";
                    document.getElementById('game-title').style.color = "#fff";
                    
                    // Show buttons if unlocked
                    if(this.unlockedLayers >= 10 || (this.infinityPoints >= 1e12 || this.artifacts.prism)) {
                        document.getElementById('warp-btn').style.display = 'block';
                    }
                    if(this.infinityPoints >= 1e12 || this.artifacts.prism) {
                        document.getElementById('reality-btn').style.display = 'block';
                    }
                    
                    // Reset camera
                    Renderer.cameraX = 0;
                    Renderer.cameraY = 0;
                    Renderer.zoom = 1.0;
                    
                    UI.buildUpgrades();
                    UI.updateRPMList();
                    UI.updateCurrList();
                    UI.buildChallenges();
                    UI.buildProfileMenu();
                    UI.updateChallengeInfo();
                    UI.updateDimensionUI();
                    UI.updateComboUI();
                    
                    flash.style.backgroundColor = '#000';
                    flash.style.opacity = 0;
                    
                    Achievements.show("CHALLENGE ACTIVATED", challenge.name, "#ffd700");
                }, 500);
            },
            
            checkChallengeCompletion() {
                if(!this.reality.activeChallenge) return;
                const challenge = CONFIG.challenges.find(c => c.id === this.reality.activeChallenge);
                if(!challenge) return;
                
                if(challenge.condition(this)) {
                    // Complete challenge
                    if(!this.reality.completedChallenges) this.reality.completedChallenges = [];
                    if(!this.reality.completedChallenges.includes(challenge.id)) {
                        this.reality.completedChallenges.push(challenge.id);
                        if(!this.reality.universalConstants) this.reality.universalConstants = { torqueMultiplier: 0, shardMultiplier: 0, frictionReduction: 0, speedBoost: 0 };
                        this.reality.universalConstants[challenge.rewardType] += challenge.rewardValue;
                        Achievements.show("CHALLENGE COMPLETE", challenge.reward, "#0ff");
                        UI.buildChallenges();
                    }
                    this.reality.activeChallenge = null;
                }
            },

            runAutoBuy() {
                if(!this.autoBuyEnabled || this.dimension === 1) return;
                for(let i = 0; i < this.unlockedLayers; i++) {
                    if(!this.layerAutoBuy[i]) continue; 
                    ['speed', 'value', 'auto'].forEach(type => {
                        let cost = this.calculateSingleCost(i, type, this.rings[i].upgrades[type]);
                        if(this.resources[i] >= cost) {
                            this.resources[i] -= cost;
                            this.rings[i].upgrades[type]++;
                        }
                    });
                }
                UI.updateButtons();
            },

            toggleAutoBuy() {
                this.autoBuyEnabled = !this.autoBuyEnabled;
                const btn = document.getElementById('auto-toggle-btn');
                if(btn) {
                    btn.innerText = 'AUTO-BUY: ' + (this.autoBuyEnabled ? 'ON' : 'OFF');
                    if(this.autoBuyEnabled) btn.classList.add('active'); else btn.classList.remove('active');
                }
            },

            toggleFloater(idx) {
                this.floatersEnabled[idx] = !this.floatersEnabled[idx];
                UI.buildUpgrades(); 
            },

            save() {
                // DO NOT SAVE IF WE ARE IN THE PROCESS OF WIPING
                if(this._isResetting) return;
                
                const saveData = {
                    version: 8.4,
                    resources: this.resources,
                    rings: this.rings,
                    chronons: this.chronons,
                    autoBuyEnabled: this.autoBuyEnabled,
                    layerAutoBuy: this.layerAutoBuy,
                    layerAutoBuyPurchased: this.layerAutoBuyPurchased,
                    floatersEnabled: this.floatersEnabled,
                    unlockedLayers: this.unlockedLayers,
                    dimension: this.dimension,
                    infinityPoints: this.infinityPoints,
                    blackHoleSize: this.blackHoleSize,
                    blackHoleMass: this.blackHoleMass,
                    infUpgrades: this.infUpgrades,
                    cosmicParticles: this.cosmicParticles,
                    singularityPoints: this.singularityPoints,
                    maxEssenceReached: this.maxEssenceReached,
                    singularityUpgrades: this.singularityUpgrades,
                    reality: this.reality,
                    artifacts: this.artifacts,
                    profiles: this.profiles,
                    currentProfile: this.currentProfile,
                    selectedRPM: this.selectedRPM,
                    encounteredEvents: this.encounteredEvents || [],
                    settings: this.settings || { floaters: true, autoSelectMaterial: false }
                };
                localStorage.setItem('chronoCyclesSave', JSON.stringify(saveData));
            },

            load() {
                const saved = localStorage.getItem('chronoCyclesSave');
                if(!saved) return false;
                try {
                    const data = JSON.parse(saved);
                    if(data.resources) this.resources = data.resources;
                    if(data.rings) {
                        this.rings = data.rings;
                        // Set _highSpeedTime for rings over 3000 RPM to prevent ticks on load
                        this.rings.forEach(ring => {
                            if(ring.velocity >= 3000 && !ring._highSpeedTime) {
                                ring._highSpeedTime = performance.now() - 2000; // Set to 2 seconds ago so ticks are muted
                            }
                        });
                    }
                    if(data.chronons !== undefined) this.chronons = data.chronons;
                    if(data.autoBuyEnabled !== undefined) this.autoBuyEnabled = data.autoBuyEnabled;
                    if(data.layerAutoBuy) this.layerAutoBuy = data.layerAutoBuy;
                    if(data.layerAutoBuyPurchased) this.layerAutoBuyPurchased = data.layerAutoBuyPurchased;
                    else this.layerAutoBuyPurchased = new Array(10).fill(false);
                    if(data.floatersEnabled) this.floatersEnabled = data.floatersEnabled;
                    if(data.unlockedLayers !== undefined) this.unlockedLayers = data.unlockedLayers;
                    if(data.dimension !== undefined) this.dimension = data.dimension;
                    if(data.infinityPoints !== undefined) this.infinityPoints = data.infinityPoints;
                    if(data.blackHoleSize !== undefined) this.blackHoleSize = data.blackHoleSize;
                    if(data.blackHoleMass !== undefined) this.blackHoleMass = data.blackHoleMass;
                    if(data.infUpgrades !== undefined) {
                        this.infUpgrades = data.infUpgrades;
                        if(!this.infUpgrades.particles) this.infUpgrades.particles = 0;
                    }
                    if(data.singularityPoints !== undefined) this.singularityPoints = data.singularityPoints;
                    else this.singularityPoints = 0;
                    if(data.maxEssenceReached !== undefined) this.maxEssenceReached = data.maxEssenceReached;
                    else this.maxEssenceReached = 0;
                    if(data.singularityUpgrades !== undefined) this.singularityUpgrades = data.singularityUpgrades;
                    else this.singularityUpgrades = { resonance: 0, efficiency: 0, density: 0, cascade: 0 };
                    if(data.cosmicParticles && data.cosmicParticles.length > 0) {
                        // On refresh, clear existing particles and respawn them with staggered delays over 1-2 seconds
                        this.cosmicParticles = [];
                        const cosmicCount = data.cosmicParticles.length;
                        for(let i = 0; i < cosmicCount; i++) {
                            const delay = Math.random() * 2000; // Random delay 0-2000ms (1-2 seconds)
                            setTimeout(() => {
                                const p = data.cosmicParticles[i];
                                const offsetX = (Math.random() - 0.5) * 200;
                                const offsetY = (Math.random() - 0.5) * 200;
                                this.cosmicParticles.push({
                                    x: p.x + offsetX,
                                    y: p.y + offsetY,
                                    angle: p.angle || (Math.random() * Math.PI * 2),
                                    speed: p.speed || (0.5 + Math.random() * 0.5),
                                    history: []
                                });
                            }, delay);
                        }
                    } else {
                        this.cosmicParticles = [];
                    }
                    if(data.voidParticles) {
                        // Randomize void particles positions on load so they're not all in sync
                        this.voidParticles = data.voidParticles;
                        this.voidParticles.forEach(p => {
                            // Randomize position slightly to desync them
                            const offsetX = (Math.random() - 0.5) * 300;
                            const offsetY = (Math.random() - 0.5) * 300;
                            p.x += offsetX;
                            p.y += offsetY;
                        });
                    } else {
                        this.voidParticles = [];
                    }
                    if(data.reality !== undefined) this.reality = data.reality;
                    if(data.artifacts !== undefined) this.artifacts = data.artifacts;
                    
                    if(!this.reality.upgrades) this.reality.upgrades = { speed: 0, value: 0 };
                    if(!this.profiles) this.profiles = { main: null, challenges: {} };
                    if(!this.currentProfile) this.currentProfile = 'main';
                    if(!this.selectedRPM) this.selectedRPM = 0;
                    if(data.encounteredEvents) this.encounteredEvents = data.encounteredEvents;
                    else this.encounteredEvents = [];
                    if(data.settings) this.settings = data.settings;
                    else this.settings = { floaters: true, autoSelectMaterial: false };
                    
                    // Restore settings UI
                    if(this.settings.floaters !== undefined) {
                        const floatersBtn = document.getElementById('floaters-btn');
                        if(floatersBtn) {
                            floatersBtn.innerText = `FLOATING TEXT: ${this.settings.floaters ? "ON" : "OFF"}`;
                            if(this.settings.floaters) floatersBtn.classList.add('active'); 
                            else floatersBtn.classList.remove('active');
                        }
                    }
                    if(this.settings.autoSelectMaterial !== undefined) {
                        const autoSelectBtn = document.getElementById('auto-select-material-btn');
                        if(autoSelectBtn) {
                            autoSelectBtn.innerText = `AUTO-SELECT MATERIAL: ${this.settings.autoSelectMaterial ? "ON" : "OFF"}`;
                            if(this.settings.autoSelectMaterial) autoSelectBtn.classList.add('active'); 
                            else autoSelectBtn.classList.remove('active');
                        }
                    }
                    
                    // Restore UI state based on dimension
                    if(this.dimension !== undefined) {
                        setTimeout(() => {
                            this.restoreDimensionUI(this.dimension);
                            // Make sure profile button shows if in reality mode or has profiles
                            if(this.dimension === 2 || (this.profiles && Object.keys(this.profiles.challenges || {}).length > 0)) {
                                document.getElementById('profile-btn').style.display = 'block';
                            }
                            // Always show warp button if unlocked (unless in challenge)
                            const isChallenge = this.currentProfile && this.currentProfile !== 'main';
                            if(!isChallenge && (this.unlockedLayers >= 10 || (this.infinityPoints >= 1e12 || this.artifacts.prism))) {
                                document.getElementById('warp-btn').style.display = 'block';
                            }
                            // Always show reality button if unlocked (unless in challenge)
                            if(!isChallenge && (this.infinityPoints >= 1e12 || this.artifacts.prism)) {
                                document.getElementById('reality-btn').style.display = 'block';
                            }
                        }, 100);
                    }
                    
                    return true;
                } catch(e) {
                    console.error('Failed to load save:', e);
                    return false;
                }
            },
            
            restoreDimensionUI(dim) {
                if(dim === 0) {
                    // Microcosm
                    document.getElementById('return-btn').style.display = 'none';
                    document.getElementById('circle-ui-group').style.display = 'block';
                    // Show warp/reality buttons if unlocked (always, unless in challenge)
                    const isChallenge = this.currentProfile && this.currentProfile !== 'main';
                    if(!isChallenge && (this.unlockedLayers >= 10 || (this.infinityPoints >= 1e12 || this.artifacts.prism))) {
                        document.getElementById('warp-btn').style.display = 'block';
                    } else {
                        document.getElementById('warp-btn').style.display = 'none';
                    }
                    if(!isChallenge && (this.infinityPoints >= 1e12 || this.artifacts.prism)) {
                        document.getElementById('reality-btn').style.display = 'block';
                    } else {
                        document.getElementById('reality-btn').style.display = 'none';
                    }
                    document.getElementById('forge-open-btn').style.display = 'none';
                    document.getElementById('challenges-open-btn').style.display = 'none';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('game-title').innerText = "CHRONO ENGINE";
                    document.getElementById('game-title').style.color = "#fff";
                    document.querySelector('.currency-select').style.pointerEvents = "auto";
                    UI.buildUpgrades();
                    UI.updateCurrList();
                    UI.selectCurr(this.selectedRes || 0);
                } else if(dim === 1) {
                    // Infinity
                    document.getElementById('warp-btn').style.display = 'none';
                    document.getElementById('return-btn').style.display = 'block';
                    document.getElementById('circle-ui-group').style.display = 'none';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('forge-open-btn').style.display = 'block';
                    document.getElementById('reality-btn').style.display = (this.infinityPoints >= 1e12 || this.artifacts.prism) ? 'block' : 'none';
                    // Hide warp button in infinity dimension
                    document.getElementById('warp-btn').style.display = 'none';
                    // Show Singularity button if enough essence
                    const singularityBtn = document.getElementById('singularity-btn');
                    if(singularityBtn) {
                        const hasEnough = (Game.maxEssenceReached >= 1e8) || (Game.infinityPoints >= 1e8);
                        if(hasEnough) {
                            singularityBtn.style.display = 'block';
                        } else {
                            singularityBtn.style.display = 'none';
                        }
                    }
                    UI.updateSingularityUI(); // Update modal content
                    document.getElementById('game-title').innerText = "INFINITY ENGINE";
                    document.getElementById('game-title').style.color = "#bd00ff";
                    document.querySelector('.currency-select').style.pointerEvents = "none";
                    document.getElementById('main-display-name').innerText = "INFINITY ESSENCE";
                    document.getElementById('main-display-name').style.color = "#bd00ff";
                    document.getElementById('main-display-val').style.color = "#bd00ff";
                    document.getElementById('particle-info').style.display = 'block';
                    UI.buildInfinityUpgrades();
                    UI.updateParticleRates();
                    UI.updateComboUI();
                } else if(dim === 2) {
                    // Reality
                    document.getElementById('return-btn').style.display = 'block';
                    document.getElementById('return-btn').innerText = "<< RETURN TO MICROCOSM";
                    document.getElementById('circle-ui-group').style.display = 'block';
                    document.querySelector('.currency-select').style.pointerEvents = "auto";
                    document.getElementById('reality-btn').style.display = 'none';
                    document.getElementById('forge-open-btn').style.display = 'none';
                    document.getElementById('challenges-open-btn').style.display = 'block';
                    document.getElementById('profile-btn').style.display = 'block';
                    document.getElementById('click-combo-container').style.display = 'block';
                    document.getElementById('game-title').innerText = "REALITY ENGINE";
                    document.getElementById('game-title').style.color = "#ffd700";
                    UI.buildUpgrades();
                    UI.selectCurr(10);
                    UI.updateComboUI();
                }
                UI.updateDimensionUI();
            },


            addTorque(idx, amount) {
                if(isNaN(this.rings[idx].torque)) this.rings[idx].torque = 0;
                this.rings[idx].torque += amount;
                if(this.rings[idx].torque > CONFIG.maxTorque) this.rings[idx].torque = CONFIG.maxTorque;
            },

            getSynergyBoost(idx) {
                if (idx === 0) return 1.0; 
                const threshold = 10000000 * Math.pow(10, idx - 1);
                const parentRes = this.resources[idx - 1];
                return 1.0 + (parentRes / threshold);
            },

            getChrononBoost() { 
                let base = 1 + (this.chronons * 0.1);
                if(this.artifacts.amplifier) base *= 1.25; // +25% from artifact
                return base;
            },

            getLayerMult(idx) {
                let speedMult = 1 + (this.rings[idx].upgrades.speed * 0.25);
                let weight = 1 / (idx * 0.4 + 1);
                let globalBoost = this.getChrononBoost();
                let evtSpeed = this.eventSpeed || 1;
                let comboBoost = 1 + this.clickCombo;
                return speedMult * weight * globalBoost * evtSpeed * comboBoost;
            },

            triggerEvent() {
                const events = [
                    { name: "SOLAR FLARE", desc: "Energy Production x2", type: "evt-solar", dur: 25, rarity: 1, apply: (g) => g.eventMult = 2 },
                    { name: "TIME DILATION", desc: "System Speed x0.5", type: "evt-time", dur: 20, rarity: 1, apply: (g) => g.eventSpeed = 0.5 },
                    { name: "KINETIC SURGE", desc: "System Speed x1.5", type: "evt-warp", dur: 20, rarity: 1, apply: (g) => g.eventSpeed = 1.5 },
                    { name: "METEOR SHOWER", desc: "Torque +50 to All Layers", type: "evt-solar", dur: 5, rarity: 1, apply: (g) => g.rings.forEach(r => r.torque += 50) },
                    { name: "COSMIC ALIGNMENT", desc: "Friction Reduced by 50%", type: "evt-void", dur: 25, rarity: 1, apply: (g) => g.eventFriction = 0.5 },
                    { name: "QUANTUM TUNNEL", desc: "Instant 60s Production", type: "evt-warp", dur: 3, rarity: 1, apply: (g) => { 
                        g.rings.forEach((r, i) => { if(i < 10) g.resources[i] += r.velocity * 60 * r.baseVal; });
                        UI.spawnText("QUANTUM SKIP!", 0, true);
                    }},
                    { name: "KINETIC FRENZY", desc: "Clicking Adds 5% Current RPM (Stackable)", type: "evt-frenzy", dur: 20, rarity: 1, apply: (g) => {} },
                    // RARE EVENTS (rarity 0.2 = 5x rarer)
                    { name: "CHRONON STORM", desc: "Chronon gain x3 for next prestige", type: "evt-warp", dur: 30, rarity: 0.2, apply: (g) => g.eventChrononMult = 3 },
                    { name: "PERFECT SYNC", desc: "All rings gain 1000 RPM instantly", type: "evt-solar", dur: 2, rarity: 0.2, apply: (g) => { 
                        g.rings.forEach(r => r.velocity += 1000);
                        UI.spawnText("PERFECT SYNC!", 0, true);
                    }},
                    { name: "TEMPORAL FLOOD", desc: "Resources gain x5 for 15s", type: "evt-warp", dur: 15, rarity: 0.3, apply: (g) => g.eventMult = 5 },
                    { name: "VOID BREACH", desc: "Essence gain x10 in Infinity", type: "evt-void", dur: 20, rarity: 0.25, apply: (g) => g.eventEssenceMult = 10 },
                    { name: "ZERO FRICTION", desc: "Friction = 0 for 10s", type: "evt-void", dur: 10, rarity: 0.3, apply: (g) => g.eventFriction = 0 },
                    { name: "HYPERDRIVE", desc: "System Speed x3", type: "evt-warp", dur: 12, rarity: 0.25, apply: (g) => g.eventSpeed = 3 },
                    // EVEN RARER EVENTS (rarity 0.1-0.15 = 10x rarer)
                    { name: "TEMPORAL COLLAPSE", desc: "All resources x10 instantly", type: "evt-warp", dur: 1, rarity: 0.1, apply: (g) => {
                        g.resources.forEach((r, i) => g.resources[i] *= 10);
                        UI.spawnText("TEMPORAL COLLAPSE!", 0, true);
                    }},
                    { name: "INFINITY CASCADE", desc: "Essence gain x100 for 5s", type: "evt-void", dur: 5, rarity: 0.15, apply: (g) => g.eventEssenceMult = 100 },
                    { name: "CHRONON FLOOD", desc: "Next prestige gives x10 Chronons", type: "evt-warp", dur: 60, rarity: 0.1, apply: (g) => g.eventChrononMult = 10 }
                ];
                
                // Weighted random - rare events have lower chance
                let totalWeight = 0;
                events.forEach(e => {
                    totalWeight += e.rarity || 1;
                });
                let rand = Math.random() * totalWeight;
                let selectedEvent = null;
                for(let e of events) {
                    rand -= (e.rarity || 1);
                    if(rand <= 0) {
                        selectedEvent = e;
                        break;
                    }
                }
                if(!selectedEvent) selectedEvent = events[0];
                
                const ev = selectedEvent;
                this.activeEvent = ev;
                this.eventTimer = ev.dur;
                this.eventTotalTime = ev.dur;
                this.eventMult = 1; 
                this.eventSpeed = 1; 
                this.eventFriction = 1;
                this.eventChrononMult = 1; 
                this.eventEssenceMult = 1;
                ev.apply(this);
                
                // Track encountered event
                this.encounteredEvents = this.encounteredEvents || [];
                if(!this.encounteredEvents.includes(ev.name)) {
                    this.encounteredEvents.push(ev.name);
                }
                
                // Update events library
                UI.buildEventsLibrary();
                
                const banner = document.getElementById('event-banner');
                banner.className = ""; 
                banner.classList.add(ev.type); 
                banner.querySelector('.event-title').innerText = ev.name;
                banner.querySelector('.event-desc').innerText = ev.desc;
                banner.classList.add('active');
            },

            tick(dt) {
                if (isNaN(dt) || dt > 0.1) dt = 0.016; 
                
                try {
                    this.runAutoBuy();

                    // CLICK COMBO DECAY (per-layer, including reality ring index 10)
                    this.layerComboGrace = this.layerComboGrace || new Array(11).fill(0);
                    for(let i = 0; i < 11; i++) {
                        if(this.layerComboGrace[i] > 0) {
                            this.layerComboGrace[i] -= dt;
                        } else if((this.layerClickCombo[i] || 0) > 0 && !this.artifacts.anchor) {
                            this.layerClickCombo[i] -= dt * 0.1;
                            if(this.layerClickCombo[i] < 0) this.layerClickCombo[i] = 0;
                        }
                    }
                    
                    // Blackhole combo decay
                    if(this.blackHoleComboGrace > 0) {
                        this.blackHoleComboGrace -= dt;
                    } else if(this.blackHoleCombo > 0 && !this.artifacts.anchor) {
                        this.blackHoleCombo -= dt * 0.1;
                        if(this.blackHoleCombo < 0) this.blackHoleCombo = 0;
                    }
                    
                    UI.updateComboUI();

                    // Track max essence reached for Singularity Collapse
                    if(this.dimension === 1 && this.infinityPoints > this.maxEssenceReached) {
                        this.maxEssenceReached = this.infinityPoints;
                    }

                    // PARTICLE LOGIC (VOID SIPHON) - EXPONENTIAL BUFF
                    if (this.dimension === 1) {
                        // Math: 1.5 ^ level - increased max particles for more visual density
                        // Particle Density: adds starting particles
                        const densityBonus = (this.singularityUpgrades.density || 0) * 5;
                        const targetCount = Math.min(150, Math.floor(Math.pow(1.5, this.infUpgrades.void)) * 3 + densityBonus);
                        // Auto-gain from high levels without particles (exponential)
                        // Essence Cascade: lowers activation level
                        const cascadeLevel = this.singularityUpgrades.cascade || 0;
                        const activationLevel = Math.max(1, 10 - cascadeLevel * 2);
                        if(this.infUpgrades.void > activationLevel) {
                            const resonanceMult = 1 + ((this.singularityUpgrades.resonance || 0) * 0.1);
                            let autoGain = Math.pow(1.8, this.infUpgrades.void) * dt * resonanceMult;
                            this.infinityPoints += autoGain;
                            // Track gain for rate calculation (void_auto doesn't have combo, so use 1.0)
                            this._essenceGainHistory = this._essenceGainHistory || [];
                            this._essenceGainHistory.push({ 
                                amount: autoGain, 
                                time: performance.now(), 
                                source: 'void_auto',
                                combo: 1.0 // Auto-gain doesn't have combo
                            });
                            // Keep only last 2 seconds
                            this._essenceGainHistory = this._essenceGainHistory.filter(h => performance.now() - h.time < 2000);
                        }

                        // Spawn particles with staggered timing over 1 second to look random
                        const needed = targetCount - this.voidParticles.length;
                        if(needed > 0) {
                            // Track spawn delays to avoid multiple simultaneous spawns
                            if(!this._voidParticleSpawnQueue) this._voidParticleSpawnQueue = [];
                            const now = performance.now();
                            this._voidParticleSpawnQueue = this._voidParticleSpawnQueue.filter(t => now - t < 1000);
                            
                            // Spawn particles with random delays up to 1 second
                            for(let i = 0; i < needed; i++) {
                                const delay = Math.random() * 1000; // Random delay 0-1000ms
                                setTimeout(() => {
                                    Renderer.spawnVoidParticle();
                                    this._voidParticleSpawnQueue.push(performance.now());
                                }, delay);
                            }
                        }
                        if (this.voidParticles.length > targetCount) {
                            this.voidParticles.length = targetCount;
                        }
                        
                        this.voidParticles.forEach(p => {
                            let dx = (window.innerWidth/2) - p.x;
                            let dy = (window.innerHeight/2) - p.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            // Frame-rate independent movement - pixels per second
                            // Original: 0.02 * distance per frame = ~120 pixels/sec at typical distances
                            const voidSpeed = 1200; // pixels per second (much faster!)
                            p.x += (dx / dist) * voidSpeed * dt; 
                            p.y += (dy / dist) * voidSpeed * dt;
                            if(dist < 20) {
                                // Void particles gain essence with click combo boost
                                const comboBoost = 1 + (this.blackHoleCombo || 0); // Click combo boost
                                const resonanceMult = 1 + ((this.singularityUpgrades.resonance || 0) * 0.1); // Void Resonance upgrade
                                let voidGain = 1 * (this.eventEssenceMult || 1) * comboBoost * resonanceMult;
                                this.infinityPoints += voidGain;
                                // Track gain for rate calculation (include combo for scaling)
                                this._essenceGainHistory = this._essenceGainHistory || [];
                                this._essenceGainHistory.push({ 
                                    amount: voidGain, 
                                    time: performance.now(), 
                                    source: 'void_particle',
                                    combo: comboBoost // Track combo at time of gain
                                });
                                // Keep only last 2 seconds
                                this._essenceGainHistory = this._essenceGainHistory.filter(h => performance.now() - h.time < 2000);
                                UI.updateMainDisplay();
                                // Respawn with random position to keep particles desynced
                                let ang = Math.random() * Math.PI * 2;
                                let r = Math.max(window.innerWidth, window.innerHeight)/1.5;
                                const offsetX = (Math.random() - 0.5) * 200;
                                const offsetY = (Math.random() - 0.5) * 200;
                                p.x = (window.innerWidth/2) + Math.cos(ang)*r + offsetX;
                                p.y = (window.innerHeight/2) + Math.sin(ang)*r + offsetY;
                                p.history = [];
                            }
                            p.history.push({x: p.x, y: p.y});
                            if(p.history.length > 5) p.history.shift(); // Half the trail length
                        });

                        // Cosmic Particles (satisfying particles) - spawn with staggered timing
                        const cosmicCount = this.infUpgrades.particles || 0;
                        const cosmicNeeded = cosmicCount - this.cosmicParticles.length;
                        if(cosmicNeeded > 0) {
                            // Spawn cosmic particles with random delays over 1 second to look random
                            for(let i = 0; i < cosmicNeeded; i++) {
                                const delay = Math.random() * 2000; // Random delay 0-2000ms (1-2 seconds)
                                setTimeout(() => {
                                    if(this.cosmicParticles.length < cosmicCount) {
                                        let ang = Math.random() * Math.PI * 2;
                                        let r = Math.max(window.innerWidth, window.innerHeight) / 2;
                                        // Randomize position slightly to desync particles
                                        const offsetX = (Math.random() - 0.5) * 200;
                                        const offsetY = (Math.random() - 0.5) * 200;
                                        this.cosmicParticles.push({
                                            x: (window.innerWidth/2) + Math.cos(ang)*r + offsetX,
                                            y: (window.innerHeight/2) + Math.sin(ang)*r + offsetY,
                                            angle: ang + Math.PI,
                                            speed: 0.5 + Math.random() * 0.5,
                                            history: []
                                        });
                                    }
                                }, delay);
                            }
                        }
                        if(this.cosmicParticles.length > cosmicCount) {
                            this.cosmicParticles.length = cosmicCount;
                        }
                        
                        this.cosmicParticles.forEach(p => {
                            let dx = (window.innerWidth/2) - p.x;
                            let dy = (window.innerHeight/2) - p.y;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Spiral around blackhole - orbital mechanics (much faster)
                            let angleToCenter = Math.atan2(dy, dx);
                            let tangentialAngle = angleToCenter + Math.PI / 2; // Perpendicular to radius
                            
                            // Orbital velocity (faster as it gets closer) - frame-rate independent
                            // Speeds converted to pixels per second and multiplied by dt
                            const maxDist = Math.max(window.innerWidth, window.innerHeight) / 2;
                            // Original: orbital ~4-8 pixels/frame, radial ~3.6 pixels/frame at 60fps
                            // Convert to per-second: multiply by ~60, but keep speeds reasonable
                            let orbitalSpeedPerSec = (20 + (1 - dist / maxDist) * 30) * 5 * 10; // ~100-250 pixels/sec orbital
                            let radialSpeedPerSec = 12 * 5 * 10; // ~300 pixels/sec radial (faster inward pull)
                            
                            // Combine orbital and radial motion - frame-rate independent
                            p.x += (Math.cos(tangentialAngle) * orbitalSpeedPerSec + Math.cos(angleToCenter) * radialSpeedPerSec) * dt;
                            p.y += (Math.sin(tangentialAngle) * orbitalSpeedPerSec + Math.sin(angleToCenter) * radialSpeedPerSec) * dt;
                            
                            if(dist < this.blackHoleSize + 10) {
                                // Particle absorbed - give exponential essence based on upgrade level
                                // Base 5, multiplied exponentially by particle upgrade level
                                const particleLevel = this.infUpgrades.particles || 0;
                                const baseCosmicGain = 5;
                                const exponentialMult = Math.pow(1.5, particleLevel); // 1.5x per level
                                const comboBoost = 1 + (this.blackHoleCombo || 0); // Click combo boost
                                const resonanceMult = 1 + ((this.singularityUpgrades.resonance || 0) * 0.1); // Void Resonance upgrade
                                let cosmicGain = baseCosmicGain * exponentialMult * (this.eventEssenceMult || 1) * comboBoost * resonanceMult;
                                this.infinityPoints += cosmicGain;
                                // Track gain for rate calculation (include combo for scaling)
                                this._essenceGainHistory = this._essenceGainHistory || [];
                                this._essenceGainHistory.push({ 
                                    amount: cosmicGain, 
                                    time: performance.now(), 
                                    source: 'cosmic_particle',
                                    combo: comboBoost // Track combo at time of gain
                                });
                                // Keep only last 2 seconds
                                this._essenceGainHistory = this._essenceGainHistory.filter(h => performance.now() - h.time < 2000);
                                UI.updateMainDisplay();
                                // Particle absorbed, respawn
                                let ang = Math.random() * Math.PI * 2;
                                let r = Math.max(window.innerWidth, window.innerHeight) / 2;
                                p.x = (window.innerWidth/2) + Math.cos(ang)*r;
                                p.y = (window.innerHeight/2) + Math.sin(ang)*r;
                                p.history = [];
                            }
                            p.history.push({x: p.x, y: p.y});
                            if(p.history.length > 8) p.history.shift(); // Shorter trail
                        });
                        
                        // Constellation Passive Boost
                        // Count unlocked stars (simple approximation based on Essence)
                        if(this.infinityPoints > 1000) {
                            let boost = Math.log10(this.infinityPoints) * 0.5;
                            // Apply to something? Currently just visual, user asked for buff.
                            // Applying to Chronon boost for synergy
                        }
                    }

                    if(this.dimension === 1 && (this.infinityPoints >= 1e12 || this.artifacts.prism)) {
                        document.getElementById('reality-btn').style.display = 'block';
                    }

                    if (this.activeEvent) {
                        this.eventTimer -= dt;
                        const pct = (this.eventTimer / this.eventTotalTime) * 100;
                        document.getElementById('event-fill').style.width = pct + "%";
                        if(this.eventTimer <= 0) {
                            this.activeEvent = null;
                            // Reset event multipliers
                            this.eventMult = 1;
                            this.eventSpeed = 1;
                            this.eventFriction = 1;
                            this.eventChrononMult = 1;
                            this.eventEssenceMult = 1;
                            this.eventMult = 1; this.eventSpeed = 1; this.eventFriction = 1;
                            document.getElementById('event-banner').classList.remove('active');
                        }
                    } else {
                        this.nextEventTime -= dt;
                        if(this.nextEventTime <= 0) {
                            this.triggerEvent();
                            this.nextEventTime = Math.random() * 90 + 90; 
                        }
                    }

                    // AUTO-DISABLE FLOATERS LOGIC
                    if (!this.hasAutoDisabledFloaters && this.unlockedLayers === 10) {
                        let allMax = true;
                        this.rings.forEach(r => { if(r.velocity < CONFIG.visualRPMCap) allMax = false; });
                        if(allMax && !this.disableScheduled) {
                            this.disableScheduled = true;
                            setTimeout(() => {
                                if (!this.hasAutoDisabledFloaters) {
                                    this.settings.floaters = false;
                                    this.hasAutoDisabledFloaters = true;
                                    const btn = document.getElementById('floaters-btn');
                                    btn.innerText = "FLOATING TEXT: OFF";
                                    btn.classList.remove('active');
                                    document.getElementById('settings-hint').style.display = 'block';
                                    Achievements.show("Singularity Stabilized", "Adding balance to the universe.", "#40e0d0");
                                    UI.setLore("The Universe has stabilized. The noise of creation fades.");
                                }
                            }, 1000); 
                        }
                    }

                    // Apply challenge physics modifications
                    if(this.reality.activeChallenge) {
                        const challenge = CONFIG.challenges.find(c => c.id === this.reality.activeChallenge);
                        if(challenge) {
                            if(challenge.id === 'frictionless') {
                                // Friction is 0, torque capped at 1
                                this._challengeFriction = 0;
                                this._challengeMaxTorque = 1;
                            } else if(challenge.id === 'entropy') {
                                // Only first ring works
                                for(let i = 1; i < 10; i++) {
                                    if(this.rings[i]) {
                                        this.rings[i].torque = 0;
                                        this.rings[i].velocity = 0;
                                    }
                                }
                            } else if(challenge.id === 'reverse') {
                                // All rings spin backwards
                                this.rings.forEach(r => {
                                    if(r.velocity > 0) r.velocity = -r.velocity;
                                });
                            }
                        }
                    }
                    
                    // Apply Universal Constants
                    if(this.reality.universalConstants) {
                        this._universalTorqueMult = 1 + (this.reality.universalConstants.torqueMultiplier || 0);
                        this._universalShardMult = 1 + (this.reality.universalConstants.shardMultiplier || 0);
                        this._universalSpeedBoost = 1 + (this.reality.universalConstants.speedBoost || 0);
                    }
                    
                    // PHYSICS LOOP (INNER)
                    let totalInnerRPM = 0;
                    this.rings.forEach((ring, i) => {
                        if (i >= this.unlockedLayers) return;
                        
                        let minTorque = ring.upgrades.auto * 25; 
                        let fric = CONFIG.friction * (this.eventFriction !== undefined ? this.eventFriction : 1);
                        if(this._challengeFriction !== undefined) fric = this._challengeFriction;
                        if(this.reality.universalConstants && this.reality.universalConstants.frictionReduction) {
                            fric *= (1 - this.reality.universalConstants.frictionReduction);
                        }

                        if (ring.torque > minTorque) {
                            ring.torque -= fric * dt * (1 + ring.torque * 0.02);
                            if (ring.torque < minTorque) ring.torque = minTorque;
                        } else if (ring.torque < minTorque) {
                            ring.torque += fric * dt * 5;
                        }
                        if(ring.torque < 0) ring.torque = 0;
                        
                        // Apply challenge torque cap
                        if(this._challengeMaxTorque !== undefined && ring.torque > this._challengeMaxTorque) {
                            ring.torque = this._challengeMaxTorque;
                        }
                        
                        // Apply universal torque multiplier
                        if(this._universalTorqueMult) {
                            ring.torque *= this._universalTorqueMult;
                        }

                        let mult = this.getLayerMult(i);
                        if(this._universalSpeedBoost) mult *= this._universalSpeedBoost;
                        let targetVelocity = ring.torque * mult;

                        ring.velocity += (targetVelocity - ring.velocity) * 5 * dt;
                        totalInnerRPM += ring.velocity;
                        
                        if(isNaN(ring.velocity)) ring.velocity = 0;

                        // MAX SPEED SOUND
                        if (ring.velocity > 2950 && ring.velocity < 1000000 && !this.hasPlayedMaxSound[i]) {
                            AudioSys.playWarp(); // Plays once then fades
                            this.hasPlayedMaxSound[i] = true;
                        }
                        if (ring.velocity < 2000) {
                            this.hasPlayedMaxSound[i] = false;
                        }

                        let rads = (ring.velocity / 60) * (Math.PI * 2) * dt;
                        ring.angle += rads;

                        if (ring.velocity >= CONFIG.visualRPMCap) ring.solidTime += dt;
                        else ring.solidTime = 0;

                        // HIGH RPM OPTIMIZATION
                        let rotations = rads / (Math.PI * 2);
                        if (rotations >= 1) {
                            let count = Math.floor(rotations);
                            ring.angle %= (Math.PI * 2);
                            this.processBulkLaps(i, count);
                        } else {
                            if (ring.angle >= Math.PI * 2) {
                                ring.angle %= (Math.PI * 2);
                                this.completeLap(i);
                            }
                        }
                    });

                    // PHYSICS LOOP (REALITY)
                    if(this.dimension === 2) {
                        let realityTorque = Math.log10(Math.max(1, totalInnerRPM)) * 1.5; // Increased base torque by 50%
                        if (this.artifacts.prism) realityTorque *= 1.1; // +10%
                        
                        // Upgrades
                        realityTorque *= (1 + this.reality.upgrades.speed * 0.2); // Speed upgrade

                        const rRing = this.reality.rings[0];
                        rRing.torque = realityTorque;
                        rRing.velocity += (rRing.torque - rRing.velocity) * dt; 
                        
                        let rRads = (rRing.velocity / 60) * (Math.PI * 2) * dt;
                        rRing.angle += rRads;
                        
                        // PAYOUT ON LAP
                        if(rRing.angle >= Math.PI * 2) {
                            rRing.angle %= (Math.PI * 2);
                            let baseVal = 1 * (1 + this.reality.upgrades.value * 0.5);
                            this.reality.shards += baseVal;
                            
                            UI.spawnText(`+${Format(baseVal)} RS`, 10, true); // Gold text
                            UI.updateMainDisplay();
                        }
                    }
                    
                    // Check challenge completion
                    this.checkChallengeCompletion();

                    if (this.dimension === 0 && this.unlockedLayers < CONFIG.layers.length) {
                        let currentRing = this.rings[this.unlockedLayers - 1];
                        if (currentRing.velocity >= CONFIG.visualRPMCap) {
                            this.unlockLayer();
                        }
                    }
                } catch (e) {
                    console.error("Game Loop Error:", e);
                }
            },

            processBulkLaps(idx, count) {
                const ring = this.rings[idx];
                if (this.dimension === 0 || this.dimension === 2) {
                    let prestigeMult = 1 + (ring.prestigeLevel * 0.5); 
                    let evtMult = this.eventMult || 1;
                    let baseReward = ring.baseVal * Math.pow(1.6, ring.upgrades.value) * this.getChrononBoost() * prestigeMult * evtMult;
                    let totalReward = baseReward * count;
                    this.resources[idx] += totalReward;
                    
                    Renderer.flash(idx);
                    
                    // AUDIO FIX: Only play TICK if velocity < 3000 or hasn't been over 3k for 1 second
                    if(ring.velocity < 3000 || (ring.velocity >= 3000 && (!ring._highSpeedTime || (performance.now() - ring._highSpeedTime) < 1000))) {
                        AudioSys.playTick(idx);
                    }
                    if(ring.velocity >= 3000 && !ring._highSpeedTime) {
                        ring._highSpeedTime = performance.now();
                    }
                    if(ring.velocity < 3000) {
                        ring._highSpeedTime = null;
                    }

                    if (this.settings.floaters && this.floatersEnabled[idx]) {
                        if(idx === this.selectedRes || Math.random() > 0.5) {
                            UI.spawnText(`+${Format(totalReward)} (x${count})`, idx);
                        }
                    }
                    if(idx === this.selectedRes) UI.updateMainDisplay();
                }
            },

            completeLap(idx) {
                this.processBulkLaps(idx, 1);
            },

            unlockLayer() {
                this.unlockedLayers++;
                const l = CONFIG.layers[this.unlockedLayers-1];
                if(this.rings[this.unlockedLayers-1]) {
                    this.rings[this.unlockedLayers-1].velocity = 0;
                    this.rings[this.unlockedLayers-1].torque = 0;
                }
                Renderer.triggerJuice(this.unlockedLayers-1, l.color);
                AudioSys.playUnlock(); 
                UI.setLore(l.lore);
                Achievements.show("SYSTEM EXPANSION", `Layer ${this.unlockedLayers} initialized: ${l.name}`, l.color);
                Achievements.unlock(`layer_${this.unlockedLayers}`);
                if(this.unlockedLayers >= 10) {
                    document.getElementById('warp-btn').style.display = 'block';
                    Achievements.show("SINGULARITY REACHED", "The Warp Gate is open.", "#40e0d0");
                    Achievements.unlock("singularity");
                }
                UI.buildUpgrades(); UI.updateRPMList(); UI.updateCurrList();
                UI.updatePrestigeUI(); 
            },

            getCostAndCount(layerIdx, type) {
                let count = 0; let cost = 0; let desired = this.buyAmount;
                let currentRes = this.resources[layerIdx];
                let currentLvl = this.rings[layerIdx].upgrades[type];

                if (desired === -1) { 
                    let safety = 1000;
                    while(safety > 0) {
                        let nextCost = this.calculateSingleCost(layerIdx, type, currentLvl + count);
                        if (currentRes >= cost + nextCost) { cost += nextCost; count++; } else break;
                        safety--;
                    }
                    if(count === 0) { cost = this.calculateSingleCost(layerIdx, type, currentLvl); count = 1; }
                } else {
                    count = desired;
                    for(let i=0; i<desired; i++) cost += this.calculateSingleCost(layerIdx, type, currentLvl + i);
                }
                return { cost, count };
            },

            calculateSingleCost(layerIdx, type, lvl) {
                if(layerIdx === 0) {
                    if (type === 'auto') return Math.floor(10 * Math.pow(2.2, lvl)); 
                    if (type === 'speed') return Math.floor(5 * Math.pow(1.6, lvl)); 
                    if (type === 'value') return Math.floor(15 * Math.pow(2.3, lvl));
                }
                let base = 100 * Math.pow(12, layerIdx); 
                if (type === 'speed') return Math.floor(base * Math.pow(2.2, lvl)); 
                if (type === 'value') return Math.floor(base * Math.pow(4.2, lvl)); 
                if (type === 'auto') return Math.floor(base * Math.pow(1.9, lvl));
                return 0;
            },

            buy(layerIdx, type) {
                let data = this.getCostAndCount(layerIdx, type);
                if(this.buyAmount !== -1 && this.resources[layerIdx] < data.cost) return; 
                if(this.buyAmount === -1 && this.resources[layerIdx] < data.cost && data.count === 1) return; 

                if (this.buyAmount !== -1 && this.resources[layerIdx] >= data.cost) {
                    this.resources[layerIdx] -= data.cost;
                    this.rings[layerIdx].upgrades[type] += data.count;
                } else if (this.buyAmount === -1) {
                    if (this.resources[layerIdx] >= data.cost) {
                        this.resources[layerIdx] -= data.cost;
                        this.rings[layerIdx].upgrades[type] += data.count;
                    }
                }
                UI.updateButtons();
                if(layerIdx === this.selectedRes) UI.updateMainDisplay();
            },

            newGame() {
                if(confirm('‚ö†Ô∏è START NEW GAME?\nThis will DELETE all progress permanently!')) {
                    this._isResetting = true;
                    localStorage.removeItem('chronoCyclesSave');
                    window.location.href = window.location.href.split('?')[0];
                }
            },
            
            hardWipe() {
                if(confirm('‚ò¢Ô∏è NUCLEAR WIPE: THIS CANNOT BE UNDONE. RESET EVERYTHING?')) {
                    this._isResetting = true;
                    localStorage.clear();
                    location.reload();
                }
            },

            cheatMoney() { this.resources.fill(1e30); this.chronons += 1000; this.infinityPoints += 1e20; UI.updatePrestigeUI(); UI.updateMainDisplay(); },
            cheatSmall() { this.resources = this.resources.map(r => r + 1e6); UI.updateMainDisplay(); },
            cheatSpeed() { this.rings.forEach(r => r.velocity *= 1.1); },
            unlockAll() { this.unlockedLayers = 10; document.getElementById('warp-btn').style.display = 'block'; UI.buildUpgrades(); UI.updateRPMList(); UI.updateCurrList(); UI.updatePrestigeUI(); },
            maxSpeed() { this.rings.forEach(r => { r.torque = 1e12; r.velocity = 1e12; }); },


            processOfflineProgress(seconds) {
                if(this.dimension === 1) return; // Skip if in Infinity dimension
                let totalEarned = 0;
                for(let i = 0; i < this.unlockedLayers; i++) {
                    const ring = this.rings[i];
                    if(ring.velocity > 0) {
                        const prestigeMult = 1 + (ring.prestigeLevel * 0.5);
                        const baseReward = ring.baseVal * Math.pow(1.6, ring.upgrades.value) * this.getChrononBoost() * prestigeMult;
                        const lapsPerSecond = ring.velocity / 60;
                        const earned = baseReward * lapsPerSecond * seconds;
                        this.resources[i] += earned;
                        if(i === 0) totalEarned = earned;
                    }
                }
                if(totalEarned > 1) {
                    const timeStr = seconds >= 3600 ? 
                        Math.round(seconds / 3600) + "h" : 
                        Math.round(seconds / 60) + "m";
                    Achievements.show("TEMPORAL SKIP", `Earned ${Format(totalEarned)} Entropy while away (${timeStr})`, "#40e0d0");
                    UI.setLore(`Offline progress: ${timeStr} of production added.`);
                }
                UI.updateMainDisplay();
            },

            loop() {
                const now = performance.now();
                const dt = (now - this.lastTime) / 1000;
                this.lastTime = now;
                this.tick(dt);
                Renderer.draw();
                if(this.dimension === 0 || this.dimension === 2) UI.updateRealtime();
                requestAnimationFrame(() => this.loop());
            }
        };

        const Renderer = {
            canvas: document.getElementById('game-canvas'),
            ctx: null, cx: 0, cy: 0,
            flashes: new Array(10).fill(0), shockwaves: [], clickWaves: [], particles: [], impulseShake: 0, stars: [],
            cameraX: 0, cameraY: 0, zoom: 1.0,
            isDragging: false, dragStartX: 0, dragStartY: 0,

            init() {
                this.ctx = this.canvas.getContext('2d');
                window.addEventListener('resize', () => this.resize());
                this.resize();
                // Init Stars - More stars for beautiful background, with glow and flicker properties
                // Expanded to 100x larger area for zooming out - need more stars to fill the space!
                for(let i=0; i<200000; i++) {
                    this.stars.push({
                        x: (Math.random() - 0.5) * 200000, // World space coordinates - 100x larger!
                        y: (Math.random() - 0.5) * 200000,
                        s: Math.random() * 3 + 0.5, // Size
                        glow: Math.random() * 0.5 + 0.5, // Glow intensity
                        flicker: Math.random() * Math.PI * 2, // Flicker phase
                        speed: Math.random() * 0.5 + 0.5 // Flicker speed
                    });
                }
                
                // Camera controls
                this.canvas.addEventListener('mousedown', (e) => {
                    if(e.button === 0) { // Left click
                        this.isDragging = true;
                        this.dragStartX = e.clientX - this.cameraX;
                        this.dragStartY = e.clientY - this.cameraY;
                    }
                });
                this.canvas.addEventListener('mousemove', (e) => {
                    if(this.isDragging) {
                        this.cameraX = e.clientX - this.dragStartX;
                        this.cameraY = e.clientY - this.dragStartY;
                    }
                });
                this.canvas.addEventListener('mouseup', () => { this.isDragging = false; });
                this.canvas.addEventListener('mouseleave', () => { this.isDragging = false; });
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.zoom = Math.max(0.1, Math.min(5.0, this.zoom * zoomFactor));
                });
            },
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.cx = this.canvas.width/2; this.cy = this.canvas.height/2;
            },
            flash(i) { this.flashes[i] = 1.0; },
            clickEffect(x, y, c) { 
                // Store click position in screen coordinates (not transformed)
                this.clickWaves.push({x,y,r:0,a:1, c}); 
            },
            
            spawnVoidParticle() {
                const ang = Math.random() * Math.PI * 2;
                const r = Math.max(window.innerWidth, window.innerHeight) / 1.5;
                // Randomize starting position to desync particles visually
                const offsetX = (Math.random() - 0.5) * 200;
                const offsetY = (Math.random() - 0.5) * 200;
                Game.voidParticles.push({
                    x: this.cx + Math.cos(ang)*r + offsetX, 
                    y: this.cy + Math.sin(ang)*r + offsetY,
                    history: [] // Added History for trails
                });
            },
            
            getGradient(r, color) {
                const grad = this.ctx.createRadialGradient(0, 0, r - 5, 0, 0, r + 5);
                grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(0.2, color); grad.addColorStop(0.5, '#fff'); grad.addColorStop(0.8, color); grad.addColorStop(1, 'rgba(0,0,0,0)');
                return grad;
            },
            triggerJuice(i, color) {
                this.shockwaves.push({ r: CONFIG.baseRadius + (i * CONFIG.spacing), w: 50, a: 1, c: color, speed: 2 });
                this.impulseShake = 20;
                const f = document.getElementById('flash-overlay');
                f.style.opacity = 0.5;
                setTimeout(() => f.style.opacity = 0, 50);
                for(let p=0; p<50; p++) {
                    const ang = Math.random() * Math.PI * 2; const spd = Math.random() * 5 + 2;
                    this.particles.push({ x: this.cx, y: this.cy, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, life: 1.0, color: color });
                }
            },
            draw() {
                this.ctx.fillStyle = '#050508'; this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
                
                // Apply camera transform for stars (they move with camera)
                this.ctx.save();
                this.ctx.translate(this.cx + this.cameraX, this.cy + this.cameraY);
                this.ctx.scale(this.zoom, this.zoom);
                
                // BEAUTIFUL STARRY BACKGROUND - Always visible, moves with camera
                // Only draw stars visible on screen (frustum culling for performance)
                const time = performance.now() * 0.001; // Time for flickering
                
                // Calculate visible bounds based on camera and zoom
                const viewWidth = this.canvas.width / this.zoom;
                const viewHeight = this.canvas.height / this.zoom;
                const viewLeft = -this.cameraX / this.zoom - viewWidth / 2;
                const viewRight = -this.cameraX / this.zoom + viewWidth / 2;
                const viewTop = -this.cameraY / this.zoom - viewHeight / 2;
                const viewBottom = -this.cameraY / this.zoom + viewHeight / 2;
                
                // Add padding for stars that might be partially visible (glow effect)
                const padding = 100;
                const visibleLeft = viewLeft - padding;
                const visibleRight = viewRight + padding;
                const visibleTop = viewTop - padding;
                const visibleBottom = viewBottom + padding;
                
                // Optimize: Reduce stars rendered when zoomed in (better performance)
                // When zoomed in, only render every Nth star to maintain performance
                const starSkip = this.zoom > 2 ? Math.ceil(this.zoom / 2) : 1;
                let starIndex = 0;
                
                this.stars.forEach(s => {
                    // Skip stars outside visible area
                    if(s.x < visibleLeft || s.x > visibleRight || s.y < visibleTop || s.y > visibleBottom) {
                        return;
                    }
                    
                    // Skip stars when zoomed in for performance
                    starIndex++;
                    if(starIndex % starSkip !== 0) return;
                    
                    // Flicker effect
                    const flickerIntensity = 0.7 + Math.sin(time * s.speed + s.flicker) * 0.3;
                    const alpha = s.glow * flickerIntensity;
                    
                    // Draw glow
                    this.ctx.globalAlpha = alpha * 0.3;
                    this.ctx.fillStyle = '#fff';
                    this.ctx.shadowColor = '#fff';
                    this.ctx.shadowBlur = s.s * 8;
                    this.ctx.beginPath();
                    this.ctx.arc(s.x, s.y, s.s * 2, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    // Draw star core
                    this.ctx.globalAlpha = alpha;
                    this.ctx.shadowBlur = s.s * 4;
                    this.ctx.beginPath();
                    this.ctx.arc(s.x, s.y, s.s, 0, Math.PI*2);
                    this.ctx.fill();
                });
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
                
                // CONSTELLATIONS Logic (only in Infinity dimension)
                if(Game.dimension === 1) {
                    this.ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    
                    // Progressive Reveal
                    let pct = Math.min(1.0, Game.infinityPoints / 10000); 
                    if(Game.artifacts.chart) pct = Math.min(1.0, Game.infinityPoints / 5000);
                    
                    if(pct > 0) {
                        // Only check stars visible on screen for constellations
                        const viewWidth = this.canvas.width / this.zoom;
                        const viewHeight = this.canvas.height / this.zoom;
                        const viewLeft = -this.cameraX / this.zoom - viewWidth / 2;
                        const viewRight = -this.cameraX / this.zoom + viewWidth / 2;
                        const viewTop = -this.cameraY / this.zoom - viewHeight / 2;
                        const viewBottom = -this.cameraY / this.zoom + viewHeight / 2;
                        
                        // Get visible stars only
                        const visibleStars = this.stars.filter(s => 
                            s.x >= viewLeft && s.x <= viewRight && 
                            s.y >= viewTop && s.y <= viewBottom
                        );
                        
                        // Limit to maximum constellation lines (much smaller number)
                        const maxLines = Math.min(50, Math.floor(visibleStars.length * 0.1 * pct));
                        const maxDistance = 5000; // Reduced distance for constellations
                        
                        let drawn = 0;
                        for(let i=0; i<visibleStars.length && drawn < maxLines; i++) {
                            for(let j=i+1; j<visibleStars.length && drawn < maxLines; j++) {
                                let s1 = visibleStars[i]; let s2 = visibleStars[j];
                                let d = Math.sqrt(Math.pow(s1.x-s2.x, 2) + Math.pow(s1.y-s2.y, 2));
                                if(d < maxDistance) {
                                    this.ctx.moveTo(s1.x, s1.y);
                                    this.ctx.lineTo(s2.x, s2.y);
                                    drawn++;
                                    if(drawn >= maxLines) break;
                                }
                            }
                            if(drawn >= maxLines) break;
                        }
                        this.ctx.stroke();
                    }
                }
                
                this.ctx.restore();

                // Apply camera transform to game objects (rings, blackhole, etc.)
                let shakeX = 0, shakeY = 0;
                if(this.impulseShake > 0) { shakeX += (Math.random() - 0.5) * this.impulseShake; shakeY += (Math.random() - 0.5) * this.impulseShake; this.impulseShake *= 0.9; }
                
                this.ctx.save();
                this.ctx.translate(this.cx + this.cameraX + shakeX, this.cy + this.cameraY + shakeY);
                this.ctx.scale(this.zoom, this.zoom);

                // DRAW VOID PARTICLES
                if(Game.dimension === 1) {
                    // Optimize: Skip particles when zoomed in to maintain performance
                    const particleSkip = this.zoom > 1.5 ? Math.ceil(this.zoom / 1.5) : 1;
                    let particleIndex = 0;
                    
                    Game.voidParticles.forEach(p => {
                        // Skip particles when zoomed in for performance
                        particleIndex++;
                        if(particleIndex % particleSkip !== 0) return;
                        
                        // Draw Head
                        this.ctx.fillStyle = '#bd00ff';
                        this.ctx.beginPath(); this.ctx.arc(p.x - this.cx, p.y - this.cy, 4, 0, Math.PI*2); this.ctx.fill();
                        
                        // Draw Trail
                        if(p.history.length > 1) {
                            this.ctx.strokeStyle = 'rgba(189, 0, 255, 0.4)';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(p.history[0].x - this.cx, p.history[0].y - this.cy);
                            for(let i=1; i<p.history.length; i++) {
                                this.ctx.lineTo(p.history[i].x - this.cx, p.history[i].y - this.cy);
                            }
                            this.ctx.stroke();
                        }
                    });
                    
                    // DRAW COSMIC PARTICLES (beautiful gradient colors)
                    particleIndex = 0;
                    Game.cosmicParticles.forEach(p => {
                        // Skip particles when zoomed in for performance
                        particleIndex++;
                        if(particleIndex % particleSkip !== 0) return;
                        
                        // Draw glowing head with gradient colors (blue to purple)
                        const gradient = this.ctx.createRadialGradient(p.x - this.cx, p.y - this.cy, 0, p.x - this.cx, p.y - this.cy, 8);
                        gradient.addColorStop(0, '#0ff');
                        gradient.addColorStop(0.5, '#9370DB');
                        gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath(); 
                        this.ctx.arc(p.x - this.cx, p.y - this.cy, 6, 0, Math.PI*2); 
                        this.ctx.fill();
                        
                        // Draw Trail with fading gradient
                        if(p.history.length > 1) {
                            this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                            this.ctx.shadowBlur = 10;
                            this.ctx.shadowColor = '#0ff';
                            this.ctx.lineWidth = 3;
                            this.ctx.beginPath();
                            this.ctx.moveTo(p.history[0].x - this.cx, p.history[0].y - this.cy);
                            for(let i=1; i<p.history.length; i++) {
                                this.ctx.lineTo(p.history[i].x - this.cx, p.history[i].y - this.cy);
                            }
                            this.ctx.stroke();
                            this.ctx.shadowBlur = 0;
                        }
                    });
                }

                for(let i=this.particles.length-1; i>=0; i--) {
                    let p = this.particles[i]; p.x += p.vx; p.y += p.vy; 
                    p.life -= 0.02;
                    this.ctx.fillStyle = p.color; this.ctx.globalAlpha = p.life;
                    this.ctx.beginPath(); this.ctx.arc(p.x - this.cx, p.y - this.cy, 3, 0, Math.PI*2); this.ctx.fill();
                    if(p.life <= 0) this.particles.splice(i,1);
                }
                this.ctx.globalAlpha = 1;

                if(Game.dimension === 0) {
                    this.drawCircles(); 
                } else if(Game.dimension === 1) {
                    this.drawInfinity();
                } else if(Game.dimension === 2) {
                    // REALITY MODE DRAWING
                    this.drawRealityRings();
                    this.ctx.save();
                    this.ctx.scale(0.15, 0.15); // ZOOM OUT
                    this.drawCircles();
                    this.ctx.restore();
                }

                for(let i=this.shockwaves.length-1; i>=0; i--) {
                    let s = this.shockwaves[i];
                    this.ctx.beginPath(); this.ctx.arc(0, 0, s.r, 0, Math.PI*2);
                    const grad = this.ctx.createRadialGradient(0, 0, s.r - 20, 0, 0, s.r + 20);
                    grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(0.5, s.c); grad.addColorStop(1, 'rgba(0,0,0,0)');
                    this.ctx.strokeStyle = grad; this.ctx.lineWidth = s.w; this.ctx.globalAlpha = s.a;
                    this.ctx.stroke(); s.r += s.speed; s.w *= 0.95; s.a -= 0.02;
                    if(s.a <= 0) this.shockwaves.splice(i, 1);
                }
                this.ctx.restore();

                this.ctx.lineWidth = 2;
                for(let i=this.clickWaves.length-1; i>=0; i--) {
                    let w = this.clickWaves[i];
                    this.ctx.strokeStyle = w.c; this.ctx.globalAlpha = w.a;
                    this.ctx.beginPath(); this.ctx.arc(w.x, w.y, w.r, 0, Math.PI*2); this.ctx.stroke();
                    w.r += 10; w.a -= 0.05; if(w.a<=0) this.clickWaves.splice(i,1);
                }
                this.ctx.globalAlpha = 1;
            },
            
            drawCircles() {
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const ring = Game.rings[i];
                    const r = CONFIG.baseRadius + (i * CONFIG.spacing);
                    const color = CONFIG.layers[i].color;
                    
                    // LIGHT SPEED BARRIER CHECK
                    if(ring.velocity > 1000000) {
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, r, 0, Math.PI*2);
                        this.ctx.lineWidth = 8;
                        this.ctx.strokeStyle = "#fff"; 
                        this.ctx.shadowColor = color;
                        this.ctx.shadowBlur = 30; 
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, r, 0, Math.PI*2);
                        this.ctx.lineWidth = 12;
                        this.ctx.strokeStyle = color;
                        this.ctx.globalAlpha = 0.3;
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                        
                        continue; 
                    }

                    if(this.flashes[i] > 0) this.flashes[i] -= 0.05;
                    let glow = Math.max(0, this.flashes[i]);
                    let rpmShakeX = 0, rpmShakeY = 0;
                    if(i === Game.unlockedLayers - 1 && i < 9) {
                        let rpm = ring.velocity;
                        if(rpm > 300) { let intensity = (rpm / 5000) * 4; rpmShakeX = (Math.random() - 0.5) * intensity; rpmShakeY = (Math.random() - 0.5) * intensity; }
                    }
                    this.ctx.save(); this.ctx.translate(rpmShakeX, rpmShakeY);
                    this.ctx.beginPath(); this.ctx.arc(0, 0, r, 0, Math.PI*2);
                    this.ctx.strokeStyle = this.getGradient(r, color); this.ctx.lineWidth = 4; this.ctx.globalAlpha = 0.4 + (glow * 0.5); this.ctx.stroke();
                    this.ctx.beginPath();
                    if (ring.velocity > CONFIG.visualRPMCap) this.ctx.arc(0, 0, r, 0, Math.PI * 2);
                    else this.ctx.arc(0, 0, r, -Math.PI/2, ring.angle - Math.PI/2);
                    this.ctx.globalAlpha = 1; this.ctx.lineWidth = 6; this.ctx.strokeStyle = color; this.ctx.shadowColor = color; this.ctx.shadowBlur = 15 + (glow * 20); this.ctx.stroke(); this.ctx.shadowBlur = 0;
                    if (ring.velocity <= CONFIG.visualRPMCap) {
                        let hx = Math.cos(ring.angle - Math.PI/2)*r; let hy = Math.sin(ring.angle - Math.PI/2)*r;
                        this.ctx.fillStyle = '#fff'; this.ctx.beginPath(); this.ctx.arc(hx, hy, 4, 0, Math.PI*2); this.ctx.fill();
                    }
                    this.ctx.restore();
                }
            },
            drawInfinity() {
                // DRAW BLACK HOLE
                this.ctx.beginPath();
                this.ctx.arc(0, 0, Game.blackHoleSize, 0, Math.PI * 2);
                this.ctx.fillStyle = "#000";
                this.ctx.fill();
                this.ctx.lineWidth = 3;
                this.ctx.strokeStyle = "#bd00ff";
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = "#bd00ff";
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;

                // ACCRETION DISC
                this.ctx.beginPath();
                this.ctx.arc(0, 0, Game.blackHoleSize + 15, 0, Math.PI*2);
                this.ctx.strokeStyle = "rgba(189, 0, 255, 0.5)"; 
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            },
            
            drawRealityRings() {
                // Draw the massive outer ring - REDUCED AGAIN in v8.2
                const r = (CONFIG.baseRadius + (0 * 80)) + 90; // Reduced from 150 to 90
                const ring = Game.reality.rings[0];
                const color = '#ffd700'; // Golden yellow
                
                // Main ring with strong glow effect
                this.ctx.beginPath();
                this.ctx.arc(0, 0, r, 0, Math.PI*2);
                this.ctx.lineWidth = 18;
                this.ctx.strokeStyle = color;
                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = 40; // Strong glow
                this.ctx.stroke();
                
                // Inner glow layer
                this.ctx.beginPath();
                this.ctx.arc(0, 0, r, 0, Math.PI*2);
                this.ctx.lineWidth = 12;
                this.ctx.strokeStyle = '#ffed4e'; // Brighter yellow
                this.ctx.shadowBlur = 25;
                this.ctx.stroke();
                
                // Active Arc
                this.ctx.beginPath();
                this.ctx.arc(0, 0, r, -Math.PI/2, ring.angle - Math.PI/2);
                this.ctx.strokeStyle = "#fff";
                this.ctx.lineWidth = 5;
                this.ctx.shadowBlur = 20;
                this.ctx.stroke();
                
                // Planet/Node indicator with glow
                let hx = Math.cos(ring.angle - Math.PI/2)*r; 
                let hy = Math.sin(ring.angle - Math.PI/2)*r;
                this.ctx.fillStyle = '#ffd700'; 
                this.ctx.shadowBlur = 25;
                this.ctx.beginPath(); 
                this.ctx.arc(hx, hy, 10, 0, Math.PI*2); 
                this.ctx.fill();
                
                this.ctx.shadowBlur = 0;
            }
        };

        const UI = {
            init() { this.buildUpgrades(); this.updateRPMList(); this.updateCurrList(); this.updatePrestigeUI(); this.updateShopUI(); this.buildAchievements(); this.updateForgeUI(); },
            toggleRPM() { if(Game.unlockedLayers > 1) document.getElementById('rpm-list').classList.toggle('open'); },
            toggleCurrList() { if(Game.unlockedLayers > 1) document.getElementById('curr-list').classList.toggle('show'); },
            selectCurr(idx) { Game.selectedRes = idx; document.getElementById('curr-list').classList.remove('show'); this.updateMainDisplay(); },
            setBuy(amount, btn) { Game.buyAmount = amount; document.querySelectorAll('.mult-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); this.updateButtons(); },
            toggleFloaters() {
                Game.settings.floaters = !Game.settings.floaters;
                const btn = document.getElementById('floaters-btn');
                btn.innerText = `FLOATING TEXT: ${Game.settings.floaters ? "ON" : "OFF"}`;
                if(Game.settings.floaters) btn.classList.add('active'); else btn.classList.remove('active');
            },
            toggleAutoSelectMaterial() {
                Game.settings.autoSelectMaterial = !Game.settings.autoSelectMaterial;
                const btn = document.getElementById('auto-select-material-btn');
                btn.innerText = `AUTO-SELECT MATERIAL: ${Game.settings.autoSelectMaterial ? "ON" : "OFF"}`;
                if(Game.settings.autoSelectMaterial) btn.classList.add('active'); else btn.classList.remove('active');
            },
            setManualPage(pageIdx, btn) {
                document.querySelectorAll('.manual-page').forEach(p => p.classList.remove('active'));
                document.querySelectorAll('.manual-tab').forEach(b => b.classList.remove('active'));
                document.getElementById(`man-page-${pageIdx}`).classList.add('active');
                btn.classList.add('active');
                if(pageIdx === 4) {
                    this.buildEventsLibrary();
                }
            },
            updateComboUI() {
                // Show combo in all dimensions (including Reality)
                if(Game.dimension === 1) {
                    // Infinity dimension - show blackhole combo
                    if(Game.blackHoleCombo > 0) {
                        document.getElementById('click-combo-container').style.opacity = 1;
                        document.getElementById('combo-text').innerText = `BLACKHOLE COMBO: +${(Game.blackHoleCombo * 100).toFixed(1)}%`;
                        const maxCombo = 0.5 + (Game.infUpgrades.weave * 0.05); // Event Horizon increases max
                        document.getElementById('combo-fill').style.width = (Game.blackHoleCombo / maxCombo * 100) + "%";
                    } else {
                        document.getElementById('click-combo-container').style.opacity = 0;
                    }
                } else {
                    // Rings combo (dimension 0) or Reality combo (dimension 2) - find highest layer combo
                    let maxCombo = 0;
                    let maxIdx = -1;
                    Game.layerClickCombo = Game.layerClickCombo || new Array(11).fill(0); // 11 to include reality ring (index 10)
                    
                    // Check all layers including reality ring (index 10)
                    for(let i = 0; i < 11; i++) {
                        if((Game.layerClickCombo[i] || 0) > maxCombo) {
                            maxCombo = Game.layerClickCombo[i];
                            maxIdx = i;
                        }
                    }
                    
                    if(maxCombo > 0) {
                        document.getElementById('click-combo-container').style.opacity = 1;
                        if(maxIdx === 10) {
                            document.getElementById('combo-text').innerText = `REALITY COMBO: +${(maxCombo * 100).toFixed(1)}%`;
                        } else {
                            document.getElementById('combo-text').innerText = `CLICK COMBO: +${(maxCombo * 100).toFixed(1)}%`;
                        }
                        // Ring combos max is 50%, doesn't use Event Horizon (that's for blackhole)
                        const maxComboVal = 0.5;
                        document.getElementById('combo-fill').style.width = (maxCombo / maxComboVal * 100) + "%";
                    } else {
                        document.getElementById('click-combo-container').style.opacity = 0;
                    }
                }
            },
            buildEventsLibrary() {
                const list = document.getElementById('events-list');
                if(!list) return;
                
                // All possible events
                const allEvents = [
                    { name: "SOLAR FLARE", desc: "Energy Production x2", rarity: 1 },
                    { name: "TIME DILATION", desc: "System Speed x0.5", rarity: 1 },
                    { name: "KINETIC SURGE", desc: "System Speed x1.5", rarity: 1 },
                    { name: "METEOR SHOWER", desc: "Torque +50 to All Layers", rarity: 1 },
                    { name: "COSMIC ALIGNMENT", desc: "Friction Reduced by 50%", rarity: 1 },
                    { name: "QUANTUM TUNNEL", desc: "Instant 60s Production", rarity: 1 },
                    { name: "KINETIC FRENZY", desc: "Clicking Adds 5% Current RPM (Stackable)", rarity: 1 },
                    { name: "CHRONON STORM", desc: "Chronon gain x3 for next prestige", rarity: 0.2, rare: true },
                    { name: "PERFECT SYNC", desc: "All rings gain 1000 RPM instantly", rarity: 0.2, rare: true },
                    { name: "TEMPORAL FLOOD", desc: "Resources gain x5 for 15s", rarity: 0.3, rare: true },
                    { name: "VOID BREACH", desc: "Essence gain x10 in Infinity", rarity: 0.25, rare: true },
                    { name: "ZERO FRICTION", desc: "Friction = 0 for 10s", rarity: 0.3, rare: true },
                    { name: "HYPERDRIVE", desc: "System Speed x3", rarity: 0.25, rare: true },
                    { name: "TEMPORAL COLLAPSE", desc: "All resources x10 instantly", rarity: 0.1, rare: true },
                    { name: "INFINITY CASCADE", desc: "Essence gain x100 for 5s", rarity: 0.15, rare: true },
                    { name: "CHRONON FLOOD", desc: "Next prestige gives x10 Chronons", rarity: 0.1, rare: true }
                ];
                
                list.innerHTML = '';
                allEvents.forEach(ev => {
                    const item = document.createElement('div');
                    item.style.cssText = 'padding:8px; margin:5px 0; border:1px solid #444; border-radius:4px;';
                    const encountered = Game.encounteredEvents && Game.encounteredEvents.includes(ev.name);
                    if(encountered) {
                        item.style.borderColor = ev.rare ? '#ffd700' : '#66ff66';
                        item.innerHTML = `<div style="color:#fff; font-weight:bold;">${ev.rare ? '‚≠ê ' : ''}${ev.name}</div><div style="color:#aaa; font-size:0.85rem;">${ev.desc}</div>`;
                    } else {
                        item.style.borderColor = '#666';
                        item.innerHTML = `<div style="color:#666; font-weight:bold;">‚ùì ???</div><div style="color:#555; font-size:0.85rem;">Event not yet encountered</div>`;
                    }
                    list.appendChild(item);
                });
            },
            updateParticleRates() {
                if(Game.dimension !== 1) {
                    const particleInfo = document.getElementById('particle-info');
                    if(particleInfo) particleInfo.style.display = 'none';
                    return;
                }
                
                const particleInfo = document.getElementById('particle-info');
                if(!particleInfo) return;
                particleInfo.style.display = 'block';
                
                // Calculate actual essence per second from tracked gains
                if(!Game._essenceGainHistory) Game._essenceGainHistory = [];
                // Filter to last 2 seconds
                const now = performance.now();
                const recentGains = Game._essenceGainHistory.filter(h => now - h.time < 2000);
                const totalEssenceGain = recentGains.reduce((sum, h) => sum + h.amount, 0);
                const timeWindow = 2; // 2 seconds
                const essencePerSecond = totalEssenceGain / timeWindow;
                
                // Calculate essence per second from each source separately
                let voidGains = 0;
                let cosmicGains = 0;
                
                // Get current combo boost - this will be used to normalize tracked gains and calculate theoretical rates
                const currentComboBoost = 1 + (Game.blackHoleCombo || 0);
                
                // Calculate average combo from tracked gains for scaling
                let voidComboSum = 0;
                let voidComboCount = 0;
                let cosmicComboSum = 0;
                let cosmicComboCount = 0;
                
                recentGains.forEach(h => {
                    if(h.source === 'void_particle' || h.source === 'void_auto') {
                        voidGains += h.amount;
                        if(h.combo) {
                            voidComboSum += h.combo;
                            voidComboCount++;
                        }
                    } else if(h.source === 'cosmic_particle') {
                        cosmicGains += h.amount;
                        if(h.combo) {
                            cosmicComboSum += h.combo;
                            cosmicComboCount++;
                        }
                    }
                    // Clicks are not counted in particle rates - only actual particles
                });
                
                // Calculate per second rates from tracked gains
                let voidRateFromTracked = voidGains / timeWindow;
                let cosmicRateFromTracked = cosmicGains / timeWindow;
                
                // Calculate average combo in tracked gains
                const avgVoidComboInTracked = voidComboCount > 0 ? voidComboSum / voidComboCount : 1.0;
                const avgCosmicComboInTracked = cosmicComboCount > 0 ? cosmicComboSum / cosmicComboCount : 1.0;
                
                // Also calculate theoretical rates based on particle counts and exponential gains
                // These use CURRENT combo boost, so they update in real-time
                const voidParticleCount = Game.voidParticles ? Game.voidParticles.length : 0;
                const cosmicParticleCount = Game.cosmicParticles ? Game.cosmicParticles.length : 0;
                const eventMult = Game.eventEssenceMult || 1;
                
                // Use tracked gains and scale by current combo to show real-time rates
                // Tracked gains have combo baked in from when they were earned
                // Scale them by current combo to show what rate you'd get NOW
                
                if(voidRateFromTracked > 0) {
                    // Scale tracked rate by current combo / average combo in tracked period
                    // This gives you the rate you'd get NOW with current combo
                    voidRate = voidRateFromTracked * (currentComboBoost / Math.max(1.0, avgVoidComboInTracked));
                } else {
                    // No tracked data yet (just started), use theoretical estimate
                    voidRate = voidParticleCount * 20 * 1 * eventMult * currentComboBoost;
                }
                
                if(cosmicRateFromTracked > 0) {
                    // Scale tracked cosmic rate by current combo
                    cosmicRate = cosmicRateFromTracked * (currentComboBoost / Math.max(1.0, avgCosmicComboInTracked));
                } else {
                    // No tracked data, use theoretical
                    const particleLevel = Game.infUpgrades.particles || 0;
                    const baseCosmicGain = 5;
                    const exponentialMult = Math.pow(1.5, particleLevel);
                    cosmicRate = cosmicParticleCount * 40 * baseCosmicGain * exponentialMult * eventMult * currentComboBoost;
                }
                
                // Ensure rates are valid numbers
                if(isNaN(voidRate) || !isFinite(voidRate)) voidRate = 0;
                if(isNaN(cosmicRate) || !isFinite(cosmicRate)) cosmicRate = 0;
                
                // Show separate rates
                document.getElementById('void-particle-rate').innerText = `Void Particles: +${Format(voidRate)}/s`;
                document.getElementById('cosmic-particle-rate').innerText = `Cosmic Particles: +${Format(cosmicRate)}/s`;
            },
            spawnComboText(text, x, y) {
                const el = document.createElement('div');
                el.innerText = text;
                el.style.position = 'absolute';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.color = '#ff3333';
                el.style.fontWeight = 'bold';
                el.style.fontSize = '1rem';
                el.style.pointerEvents = 'none';
                el.style.textShadow = '0 0 5px #000';
                el.style.animation = 'floatUp 0.5s ease-out forwards';
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 500);
            },
            updateCurrList() {
                const list = document.getElementById('curr-list'); list.innerHTML = '';
                
                // Normal layers
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const l = CONFIG.layers[i]; const div = document.createElement('div'); div.className = 'curr-opt';
                    div.style.color = l.color; 
                    div.innerHTML = `${l.name} (${l.icon})`; div.onclick = () => this.selectCurr(i); list.appendChild(div);
                }
                
                // Reality Layer check
                if(Game.dimension === 2) {
                     const l = CONFIG.realityLayers[0]; const div = document.createElement('div'); div.className = 'curr-opt';
                     div.style.color = l.color;
                     div.innerHTML = `${l.name} (${l.icon})`; div.onclick = () => this.selectCurr(10); list.appendChild(div);
                }
            },
            buildUpgrades() {
                const con = document.getElementById('upgrades'); con.innerHTML = '';
                
                // REALITY MODE UPGRADES
                if (Game.dimension === 2) {
                    const header = document.createElement('div'); 
                    header.innerHTML = `<div style="text-align:center; color:#ffd700; font-family:'Orbitron'; margin-bottom:20px; font-size:1.2rem;">REALITY ENGINE MODIFICATIONS</div>`;
                    con.appendChild(header);
                    
                    let speedCost = 10 * Math.pow(2.5, Game.reality.upgrades.speed);
                    const speedCard = document.createElement('div'); speedCard.className = 'upgrade-card';
                    speedCard.id = 'reality-btn-speed';
                    speedCard.style.borderColor = '#ffd700';
                    speedCard.innerHTML = `<div class="u-info"><span class="u-name">Temporal Threads</span><span class="u-desc">Increases Reality Torque conversion.</span><span class="u-current">Current: +${(Game.reality.upgrades.speed * 20)}%</span></div><div class="u-meta"><span class="u-cost">${Format(speedCost)} Shards</span><span class="u-lvl">LVL ${Game.reality.upgrades.speed}</span></div>`;
                    speedCard.onclick = (e) => { e.stopPropagation(); e.preventDefault(); Game.buyRealityUpgrade('speed'); };
                    if(Game.reality.shards < speedCost) { speedCard.classList.add('locked'); }
                    con.appendChild(speedCard);

                    let valCost = 10 * Math.pow(2.5, Game.reality.upgrades.value);
                    const valCard = document.createElement('div'); valCard.className = 'upgrade-card';
                    valCard.id = 'reality-btn-value';
                    valCard.style.borderColor = '#ffd700';
                    valCard.innerHTML = `<div class="u-info"><span class="u-name">Universal Scales</span><span class="u-desc">Increases Shards per rotation.</span><span class="u-current">Current: +${(Game.reality.upgrades.value * 50)}%</span></div><div class="u-meta"><span class="u-cost">${Format(valCost)} Shards</span><span class="u-lvl">LVL ${Game.reality.upgrades.value}</span></div>`;
                    valCard.onclick = (e) => { e.stopPropagation(); e.preventDefault(); Game.buyRealityUpgrade('value'); };
                    if(Game.reality.shards < valCost) { valCard.classList.add('locked'); }
                    con.appendChild(valCard);
                    
                    return;
                }

                // NORMAL MODE UPGRADES
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const layer = CONFIG.layers[i]; const group = document.createElement('div'); group.className = 'layer-group';
                    const header = document.createElement('div'); header.className = 'layer-header';
                    header.style.setProperty('--layer-color', layer.color);
                    
                    let mult = 1 + (Game.rings[i].prestigeLevel * 0.5);
                    const autoActive = Game.layerAutoBuy[i]; 
                    const autoBadge = autoActive ? ' <span style="color:#64ffda;font-size:0.8rem;">[AUTO]</span>' : '';
                    
                    const titleSpan = document.createElement('span');
                    titleSpan.innerHTML = `${layer.name} GEAR (x${mult.toFixed(1)})${autoBadge}`;
                    
                    const controlsDiv = document.createElement('div');
                    controlsDiv.style.display = 'flex';
                    controlsDiv.style.alignItems = 'center';

                    const eyeBtn = document.createElement('button');
                    eyeBtn.className = 'eye-btn' + (Game.floatersEnabled[i] ? '' : ' disabled');
                    eyeBtn.innerHTML = Game.floatersEnabled[i] ? 'üëÅÔ∏è' : 'üö´';
                    eyeBtn.title = "Toggle Floating Text for this Layer";
                    eyeBtn.onclick = (e) => { e.stopPropagation(); Game.toggleFloater(i); };
                    
                    const ocBtn = document.createElement('button');
                    ocBtn.className = 'overclock-btn';
                    ocBtn.id = `oc-btn-${i}`;
                    ocBtn.innerText = `PURIFY (x${mult.toFixed(1)} -> x${(mult + 0.5).toFixed(1)})`;
                    ocBtn.onclick = () => Game.overclockLayer(i);
                    
                    controlsDiv.appendChild(eyeBtn);
                    controlsDiv.appendChild(ocBtn);
                    header.appendChild(titleSpan);
                    header.appendChild(controlsDiv);

                    group.appendChild(header);
                    
                    let nextAuto = (Game.rings[i].upgrades.auto + 1) * 25; 
                    let multVal = Game.getLayerMult(i);
                    let projectedRPM = nextAuto * multVal;

                    let nextSpeed = ((1 + ((Game.rings[i].upgrades.speed + 1) * 0.25)) * 100).toFixed(0) + "%";
                    let nextVal = "x" + Math.pow(1.6, Game.rings[i].upgrades.value + 1).toFixed(1);

                    group.appendChild(this.createCard(i, 'auto', 'Perpetual Motor', 'Maintains minimum RPM.', layer.color, `Next: ${Format(projectedRPM)} RPM`));
                    group.appendChild(this.createCard(i, 'speed', 'Kinetic Lubricant', 'Reduces friction.', layer.color, `Next: ${nextSpeed}`));
                    group.appendChild(this.createCard(i, 'value', 'Matter Compression', 'Increases yield.', layer.color, `Next: ${nextVal}`));
                    
                    con.appendChild(group);
                }
                this.updateButtons();
            },
            buildInfinityUpgrades() {
                const con = document.getElementById('upgrades'); con.innerHTML = '';
                const header = document.createElement('div'); 
                header.innerHTML = `<div style="text-align:center; color:#bd00ff; font-family:'Orbitron'; margin-bottom:20px; font-size:1.2rem;">COSMIC WEAVE STABILIZER</div>`;
                con.appendChild(header);
                
                // Nerfed: exponential growth starts slower, scales harder after 1k essence
                // Quantum Efficiency: reduces cost scaling
                let level = Game.infUpgrades.void;
                const efficiencyMult = Math.pow(1 - (Game.singularityUpgrades.efficiency || 0) * 0.05, level);
                let cost1 = level < 10 ? (10 * Math.pow(1.5, level)) : (10 * Math.pow(1.5, 10) * Math.pow(3.0, level - 10));
                cost1 = Math.floor(cost1 * efficiencyMult);
                const card1 = document.createElement('div'); card1.className = 'upgrade-card';
                card1.style.borderColor = '#bd00ff';
                card1.dataset.cost = cost1; // Store cost for button state checking
                card1.innerHTML = `<div class="u-info"><span class="u-name">Void Siphon</span><span class="u-desc">Absorb background radiation. 1 Particle per level.</span></div><div class="u-meta"><span class="u-cost">${Format(cost1)} Essence</span><span class="u-lvl">LVL ${Game.infUpgrades.void}</span></div>`;
                if(Game.infinityPoints < cost1) {
                    card1.classList.add('locked');
                    card1.style.pointerEvents = 'none';
                } else {
                    card1.classList.remove('locked');
                    card1.style.pointerEvents = 'auto';
                }
                card1.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if(Game.infinityPoints >= cost1) { 
                        Game.infinityPoints -= cost1; 
                        Game.infUpgrades.void++; 
                        UI.updateMainDisplay(); 
                        UI.buildInfinityUpgrades(); 
                    }
                };
                con.appendChild(card1);

                let cost2 = 50 * Math.pow(2.0, Game.infUpgrades.weave);
                const card2 = document.createElement('div'); card2.className = 'upgrade-card';
                card2.style.borderColor = '#bd00ff';
                card2.dataset.cost = cost2; // Store cost for button state checking
                card2.innerHTML = `<div class="u-info"><span class="u-name">Event Horizon</span><span class="u-desc">Strengthens the singularity. Blackhole Click Combo Max +5%</span></div><div class="u-meta"><span class="u-cost">${Format(cost2)} Essence</span><span class="u-lvl">LVL ${Game.infUpgrades.weave}</span></div>`;
                if(Game.infinityPoints < cost2) {
                    card2.classList.add('locked');
                    card2.style.pointerEvents = 'none';
                } else {
                    card2.classList.remove('locked');
                    card2.style.pointerEvents = 'auto';
                }
                card2.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if(Game.infinityPoints >= cost2) { 
                        Game.infinityPoints -= cost2; 
                        Game.infUpgrades.weave++; 
                        UI.updateMainDisplay(); 
                        UI.buildInfinityUpgrades(); 
                    }
                };
                con.appendChild(card2);

                // New particle upgrade - satisfying particles that go into blackhole (always visible)
                let cost3 = 100 * Math.pow(2.5, Game.infUpgrades.particles || 0);
                const card3 = document.createElement('div'); card3.className = 'upgrade-card';
                card3.style.borderColor = '#0ff';
                card3.dataset.cost = cost3; // Store cost for button state checking
                card3.innerHTML = `<div class="u-info"><span class="u-name">Cosmic Particles</span><span class="u-desc">Beautiful particles that spiral into the blackhole. ${Game.infUpgrades.particles || 0} particles active.</span></div><div class="u-meta"><span class="u-cost">${Format(cost3)} Essence</span><span class="u-lvl">LVL ${Game.infUpgrades.particles || 0}</span></div>`;
                if(Game.infinityPoints < cost3) {
                    card3.classList.add('locked');
                    card3.style.pointerEvents = 'none';
                } else {
                    card3.classList.remove('locked');
                    card3.style.pointerEvents = 'auto';
                }
                card3.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if(Game.infinityPoints >= cost3) { 
                        Game.infinityPoints -= cost3; 
                        if(!Game.infUpgrades.particles) Game.infUpgrades.particles = 0;
                        Game.infUpgrades.particles++; 
                        UI.updateMainDisplay(); 
                        UI.buildInfinityUpgrades(); 
                    }
                };
                con.appendChild(card3);

                // Click Gain upgrade (always visible)
                let cost4 = 500 * Math.pow(2.0, Game.infUpgrades.clickGain || 0);
                const card4 = document.createElement('div'); card4.className = 'upgrade-card';
                card4.style.borderColor = '#ff6b9d';
                card4.dataset.cost = cost4; // Store cost for button state checking
                let clickMult = Game.infUpgrades.clickGain || 0;
                card4.innerHTML = `<div class="u-info"><span class="u-name">Quantum Amplifier</span><span class="u-desc">Increases Essence gained per blackhole click. x${(Math.pow(1.5, clickMult)).toFixed(2)} multiplier.</span></div><div class="u-meta"><span class="u-cost">${Format(cost4)} Essence</span><span class="u-lvl">LVL ${clickMult}</span></div>`;
                if(Game.infinityPoints < cost4) {
                    card4.classList.add('locked');
                    card4.style.pointerEvents = 'none';
                } else {
                    card4.classList.remove('locked');
                    card4.style.pointerEvents = 'auto';
                }
                card4.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if(Game.infinityPoints >= cost4) { 
                        Game.infinityPoints -= cost4; 
                        if(!Game.infUpgrades.clickGain) Game.infUpgrades.clickGain = 0;
                        Game.infUpgrades.clickGain++; 
                        UI.updateMainDisplay(); 
                        UI.buildInfinityUpgrades(); 
                    }
                };
                con.appendChild(card4);
                
            },
            updateRPMList() {
                const list = document.getElementById('rpm-list'); 
                list.innerHTML = '';
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const l = CONFIG.layers[i]; const d = document.createElement('div'); d.className = 'rpm-item';
                    d.style.cursor = 'pointer';
                    if(Game.selectedRPM === i) d.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    d.onclick = () => { 
                        Game.selectedRPM = i; 
                        UI.updateRealtime(); 
                        // Minimize the list after selection
                        const rpmList = document.getElementById('rpm-list');
                        if(rpmList) rpmList.classList.remove('open');
                    };
                    let boost = Game.getSynergyBoost(i); let boostText = boost > 1.0 ? `<span class="rpm-boost">(+${((boost-1)*100).toFixed(0)}%)</span>` : '';
                    let trueRPM = Math.floor(Game.rings[i].velocity);
                    d.innerHTML = `<span>${l.name}</span> <span class="rpm-val" id="rpm-item-${i}">${Format(trueRPM)} ${boostText}</span>`; 
                    list.appendChild(d);
                }
                // Add Reality ring RPM if in Reality mode
                if(Game.dimension === 2 && Game.reality.rings[0]) {
                    const d = document.createElement('div'); d.className = 'rpm-item';
                    d.style.cursor = 'pointer';
                    d.style.color = '#ffd700';
                    if(Game.selectedRPM === 10) d.style.backgroundColor = 'rgba(255,215,0,0.2)';
                    d.onclick = () => { 
                        Game.selectedRPM = 10; 
                        UI.updateRealtime(); 
                        // Minimize the list after selection
                        const rpmList = document.getElementById('rpm-list');
                        if(rpmList) rpmList.classList.remove('open');
                    };
                    let trueRPM = Math.floor(Game.reality.rings[0].velocity);
                    d.innerHTML = `<span>Reality Ring</span> <span class="rpm-val" id="rpm-item-reality">${Format(trueRPM)}</span>`; 
                    list.appendChild(d);
                }
            },
            createCard(layerIdx, type, name, desc, color, currentStat) {
                const el = document.createElement('div'); el.className = 'upgrade-card';
                el.style.setProperty('--layer-color', color); el.style.borderColor = color; 
                el.id = `btn-${layerIdx}-${type}`; el.onclick = () => Game.buy(layerIdx, type);
                el.innerHTML = `<div class="u-info"><span class="u-name">${name}</span><span class="u-desc">${desc}</span><span class="u-current" id="stat-${layerIdx}-${type}">${currentStat}</span></div><div class="u-meta"><span class="u-cost" id="cost-${layerIdx}-${type}">0</span><span class="u-lvl" id="lvl-${layerIdx}-${type}">LVL 0</span></div>`;
                return el;
            },
            updateButtons() {
                if(Game.dimension === 1) return; 
                if(Game.dimension === 2) {
                    // Update Reality upgrade buttons
                    let speedCost = 10 * Math.pow(2.5, Game.reality.upgrades.speed);
                    const speedBtn = document.getElementById('reality-btn-speed');
                    if(speedBtn) {
                        if(Game.reality.shards >= speedCost) {
                            speedBtn.classList.remove('locked');
                            speedBtn.style.borderColor = '#ffd700';
                        } else {
                            speedBtn.classList.add('locked');
                        }
                    }
                    
                    let valCost = 10 * Math.pow(2.5, Game.reality.upgrades.value);
                    const valBtn = document.getElementById('reality-btn-value');
                    if(valBtn) {
                        if(Game.reality.shards >= valCost) {
                            valBtn.classList.remove('locked');
                            valBtn.style.borderColor = '#ffd700';
                        } else {
                            valBtn.classList.add('locked');
                        }
                    }
                    return;
                } 

                for(let i=0; i<Game.unlockedLayers; i++) {
                    const ocBtn = document.getElementById(`oc-btn-${i}`);
                    if(ocBtn) {
                        // Purify requirement: 10 + (prestigeLevel * 5) for each upgrade
                        const requiredLevel = 10 + (Game.rings[i].prestigeLevel * 5);
                        if(Game.rings[i].upgrades.speed >= requiredLevel && Game.rings[i].upgrades.value >= requiredLevel && Game.rings[i].upgrades.auto >= requiredLevel) {
                            ocBtn.classList.add('visible');
                        } else {
                            ocBtn.classList.remove('visible');
                        }
                    }

                    ['speed', 'value', 'auto'].forEach(type => {
                        let data = Game.getCostAndCount(i, type);
                        let displayCost = data.cost; let displayLvl = Game.rings[i].upgrades[type];
                        document.getElementById(`cost-${i}-${type}`).innerText = Format(displayCost);
                        let plusText = data.count > 0 ? `+${data.count}` : ''; if(Game.buyAmount === -1) plusText = data.count > 0 ? `+${data.count}` : '(MAX)';
                        document.getElementById(`lvl-${i}-${type}`).innerText = `LVL ${displayLvl} ${plusText}`;
                        let nextLvl = displayLvl + 1; 
                        
                        let statText = "";
                        if(type==='auto') { 
                            let nextAuto = (Game.rings[i].upgrades.auto + 1) * 25; 
                            let multVal = Game.getLayerMult(i);
                            statText = `Next: ${Format(nextAuto * multVal)} RPM`; 
                        }
                        if(type==='speed') statText = `Next: ${((1 + (nextLvl * 0.25)) * 100).toFixed(0)}%`;
                        if(type==='value') statText = `Next: x${Math.pow(1.6, nextLvl).toFixed(1)}`;
                        
                        document.getElementById(`stat-${i}-${type}`).innerText = statText;
                        const btn = document.getElementById(`btn-${i}-${type}`);
                        if(Game.resources[i] >= displayCost && data.count > 0) { btn.classList.remove('locked'); btn.style.borderColor = CONFIG.layers[i].color; } else btn.classList.add('locked');
                    });
                }
            },
            updatePrestigeUI() {
                const totalVal = Game.getTotalValue();
                
                if(totalVal < 10000 && Game.chronons === 0) {
                    document.getElementById('prestige-container').style.display = 'none';
                    return;
                }
                document.getElementById('prestige-container').style.display = 'block';
                document.getElementById('chronon-val').innerText = Format(Game.chronons);
                
                // Use same formula as doPrestige
                const pending = Math.floor(Math.log10(Math.max(1, totalVal / 50000)) * 3.14159);
                const btn = document.getElementById('prestige-btn');
                
                if(totalVal >= 50000) { 
                    btn.disabled = false; btn.innerText = `REWIND (+${pending})`; 
                    btn.title = "Reset game to gain Chronons"; 
                } else { 
                    btn.disabled = true; btn.innerText = "LOCKED (Req: 50k Value)"; 
                    btn.title = "Requires 50,000 Total System Value to unlock Time Travel"; 
                }
            },
            updateShopUI() {
                document.getElementById('shop-chronon-val').innerText = Format(Game.chronons);
                const container = document.getElementById('shop-items-container');
                container.innerHTML = "";
                
                // GENERATE 10 AUTO BUY BUTTONS
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const l = CONFIG.layers[i];
                    const cost = i + 1;
                    const item = document.createElement('div');
                    item.className = 'shop-item';
                    
                    const isOwned = Game.layerAutoBuy[i];
                    
                    item.innerHTML = `
                        <div>
                            <div style="color:${l.color}; font-weight:bold; font-size:0.9rem;">AUTO-BUY: ${l.name}</div>
                            <div style="color:#666; font-size:0.7rem;">Automates upgrades for layer ${i+1}.</div>
                        </div>
                    `;
                    
                    const btn = document.createElement('button');
                    btn.className = `shop-btn ${isOwned ? 'owned' : ''}`;
                    btn.innerText = isOwned ? "OWNED" : `BUY (${cost})`;
                    btn.disabled = (!isOwned && Game.chronons < cost);
                    btn.onclick = () => Game.buyShopItem(i);
                    
                    item.appendChild(btn);
                    container.appendChild(item);
                }
            },
            updateForgeUI() {
                if(Game.artifacts.prism) { const b = document.getElementById('forge-btn-prism'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
                if(Game.artifacts.anchor) { const b = document.getElementById('forge-btn-anchor'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
                if(Game.artifacts.chart) { const b = document.getElementById('forge-btn-chart'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
                if(Game.artifacts.crystal) { const b = document.getElementById('forge-btn-crystal'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
                if(Game.artifacts.amplifier) { const b = document.getElementById('forge-btn-amplifier'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
                if(Game.artifacts.loop) { const b = document.getElementById('forge-btn-loop'); if(b) { b.innerText = "OWNED"; b.disabled=true; b.classList.add('owned'); } }
            },
            buildChallenges() {
                const modal = document.getElementById('challenges-modal');
                if(!modal) return;
                
                let html = `<div style="color:#ffd700; font-weight:bold; text-align:center; margin-bottom:15px; font-size:1.2rem;">üåå THE MULTIVERSE</div>`;
                
                if(!Game.reality.completedChallenges) Game.reality.completedChallenges = [];
                if(!Game.reality.universalConstants) Game.reality.universalConstants = { torqueMultiplier: 0, shardMultiplier: 0, frictionReduction: 0, speedBoost: 0 };
                
                CONFIG.challenges.forEach(challenge => {
                    const isCompleted = Game.reality.completedChallenges.includes(challenge.id);
                    const hasConstant = Game.reality.universalConstants[challenge.rewardType] > 0;
                    
                    html += `
                        <div style="border:2px solid ${isCompleted ? '#0f0' : '#ffd700'}; border-radius:8px; padding:15px; margin-bottom:10px; background:rgba(255,215,0,0.1);">
                            <div style="font-weight:bold; color:#ffd700; margin-bottom:5px;">${challenge.name}</div>
                            <div style="color:#aaa; font-size:0.9rem; margin-bottom:8px;">${challenge.desc}</div>
                            <div style="color:#0ff; font-size:0.85rem; margin-bottom:8px;">Reward: ${challenge.reward}</div>
                            ${isCompleted ? '<div style="color:#0f0; font-weight:bold;">‚úì COMPLETED</div>' : 
                              `<button class="toggle-btn" onclick="Game.activateChallenge('${challenge.id}')" style="width:100%;">START CHALLENGE</button>`}
                        </div>
                    `;
                });
                
                // Show Universal Constants
                html += `<div style="margin-top:20px; padding-top:15px; border-top:1px solid #444;">
                    <div style="color:#ffd700; font-weight:bold; margin-bottom:10px;">UNIVERSAL CONSTANTS</div>`;
                if(Game.reality.universalConstants.torqueMultiplier > 0) {
                    html += `<div style="color:#0ff; font-size:0.9rem;">Torque Multiplier: +${(Game.reality.universalConstants.torqueMultiplier * 100).toFixed(0)}%</div>`;
                }
                if(Game.reality.universalConstants.shardMultiplier > 0) {
                    html += `<div style="color:#0ff; font-size:0.9rem;">Shard Multiplier: +${(Game.reality.universalConstants.shardMultiplier * 100).toFixed(0)}%</div>`;
                }
                if(Game.reality.universalConstants.speedBoost > 0) {
                    html += `<div style="color:#0ff; font-size:0.9rem;">Speed Boost: +${(Game.reality.universalConstants.speedBoost * 100).toFixed(0)}%</div>`;
                }
                if(Object.values(Game.reality.universalConstants).every(v => v === 0)) {
                    html += `<div style="color:#666; font-size:0.85rem;">Complete challenges to earn Universal Constants!</div>`;
                }
                html += `</div>`;
                
                html += `<button class="toggle-btn" onclick="document.getElementById('challenges-modal').classList.remove('open')" style="margin-top:15px;">CLOSE</button>`;
                
                modal.innerHTML = html;
            },
            buildProfileMenu() {
                const list = document.getElementById('profile-list');
                if(!list) return;
                list.innerHTML = '';
                
                // Always show main profile + 3 challenge slots
                const profileSlots = [
                    { id: 'main', name: 'Main Profile', isMain: true },
                    { id: 'challenge_frictionless', name: 'Frictionless Void', isMain: false },
                    { id: 'challenge_entropy', name: 'Entropy Only', isMain: false },
                    { id: 'challenge_reverse', name: 'Reverse Polarity', isMain: false }
                ];
                
                profileSlots.forEach(slot => {
                    const exists = Game.profiles[slot.id] !== null && Game.profiles[slot.id] !== undefined;
                    const isCurrent = Game.currentProfile === slot.id;
                    
                    const item = document.createElement('div');
                    item.style.cssText = `
                        border: 2px solid ${isCurrent ? '#64ffda' : '#444'};
                        border-radius: 8px;
                        padding: 15px;
                        margin-bottom: 10px;
                        background: ${isCurrent ? 'rgba(100, 255, 218, 0.1)' : 'rgba(10, 10, 20, 0.5)'};
                        cursor: pointer;
                        transition: all 0.2s;
                    `;
                    
                    if(exists) {
                        item.innerHTML = `
                            <div style="font-weight:bold; color:${isCurrent ? '#64ffda' : '#fff'}; margin-bottom:5px;">
                                ${slot.name} ${isCurrent ? '‚úì' : ''}
                            </div>
                            <div style="color:#aaa; font-size:0.85rem;">
                                ${slot.isMain ? 'Your main game progress' : 'Challenge profile'}
                            </div>
                        `;
                        item.onclick = () => {
                            if(!isCurrent) {
                                Game.loadProfile(slot.id);
                                UI.buildProfileMenu();
                                UI.buildUpgrades();
                                UI.updateRPMList();
                                UI.updateCurrList();
                                UI.updateMainDisplay();
                                document.getElementById('profile-modal').classList.remove('open');
                            }
                        };
                    } else {
                        item.innerHTML = `
                            <div style="color:#666; font-style:italic; text-align:center;">
                                ${slot.name}<br>
                                <span style="font-size:0.8rem;">(Empty)</span>
                            </div>
                        `;
                        item.style.opacity = '0.5';
                    }
                    
                    list.appendChild(item);
                });
            },
            buildAutoBuyMenu() {
                const list = document.getElementById('autobuy-list');
                list.innerHTML = '';
                
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const l = CONFIG.layers[i];
                    const item = document.createElement('div');
                    item.className = 'shop-item';
                    item.style.marginBottom = '8px';
                    
                    const isEnabled = Game.layerAutoBuy[i];
                    const isPurchased = Game.layerAutoBuyPurchased[i];
                    const cost = Math.floor((i + 1) * Math.pow(2.5, i));
                    
                    item.innerHTML = `
                        <div>
                            <div style="color:${l.color}; font-weight:bold; font-size:0.9rem;">${l.name}</div>
                            <div style="color:#666; font-size:0.7rem;">Layer ${i+1} Auto-Buy</div>
                        </div>
                    `;
                    
                    const btn = document.createElement('button');
                    btn.className = `toggle-btn ${isEnabled ? 'active' : ''}`;
                    if(isEnabled) {
                        btn.innerText = 'ON';
                        btn.onclick = () => { Game.toggleLayerAutoBuy(i); this.buildAutoBuyMenu(); };
                    } else {
                        if(isPurchased) {
                            // Already purchased, can toggle on for free
                            btn.innerText = 'OFF';
                            btn.onclick = () => { Game.toggleLayerAutoBuy(i); this.buildAutoBuyMenu(); };
                        } else if(Game.chronons >= cost) {
                            btn.innerText = `ENABLE (${Format(cost)} Chronons)`;
                            btn.onclick = () => { Game.toggleLayerAutoBuy(i); this.buildAutoBuyMenu(); UI.updatePrestigeUI(); };
                        } else {
                            btn.innerText = `LOCKED (${Format(cost)} Chronons)`;
                            btn.disabled = true;
                        }
                    }
                    
                    item.appendChild(btn);
                    list.appendChild(item);
                }
            },
            updateInfinityButtonStates() {
                // Update button states without rebuilding entire DOM
                if(Game.dimension !== 1) return;
                
                const cards = document.querySelectorAll('#upgrades .upgrade-card');
                cards.forEach(card => {
                    // Use stored cost from dataset if available, otherwise try to parse
                    const cost = card.dataset.cost ? parseFloat(card.dataset.cost) : 0;
                    
                    if(cost > 0 && Game.infinityPoints >= cost) {
                        card.classList.remove('locked');
                        card.style.pointerEvents = 'auto';
                    } else if(cost > 0) {
                        card.classList.add('locked');
                        card.style.pointerEvents = 'none';
                    }
                });
            },
            updateSingularityUI() {
                // Update Singularity Collapse UI
                const modal = document.getElementById('singularity-modal');
                if(!modal) return;
                
                // Update displays
                document.getElementById('singularity-points-display').innerText = Format(Game.singularityPoints || 0);
                document.getElementById('max-essence-display').innerText = Format(Game.maxEssenceReached || 0);
                
                // Calculate pending Void Cores - use current essence or max reached, whichever is higher
                let pending = 0;
                const currentMax = Math.max(Game.maxEssenceReached || 0, Game.infinityPoints || 0);
                if(currentMax >= 1e9) {
                    // Fix: Ensure at least 1 core if you have 1e9 or more
                    const essenceRatio = currentMax / 1e9;
                    if(essenceRatio >= 1) {
                        pending = Math.max(1, Math.floor(Math.log10(essenceRatio) * 2.5) + 1);
                    }
                }
                document.getElementById('singularity-pending').innerText = `+${Format(pending)} Void Cores`;
                
                // Update prestige button
                const btn = document.getElementById('singularity-prestige-btn');
                if(btn) {
                    const canPrestige = currentMax >= 1e9 && Game.dimension === 1;
                    if(canPrestige) {
                        btn.disabled = false;
                        btn.innerText = `COLLAPSE SINGULARITY (+${Format(pending)})`;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                        btn.onclick = () => Game.doSingularityCollapse();
                    } else {
                        const needed = Math.max(0, 1e9 - currentMax);
                        btn.disabled = true;
                        btn.innerText = `COLLAPSE SINGULARITY (${Format(needed)} more needed)`;
                        btn.style.opacity = '0.6';
                        btn.style.cursor = 'not-allowed';
                    }
                }
                
                // Build upgrades
                this.buildSingularityUpgrades();
            },
            openSingularityModal() {
                const modal = document.getElementById('singularity-modal');
                if(modal) {
                    this.updateSingularityUI();
                    modal.classList.add('open');
                    modal.style.display = 'flex';
                }
            },
            buildSingularityUpgrades() {
                const con = document.getElementById('singularity-upgrades');
                if(!con) return;
                con.innerHTML = '';
                
                const upgrades = [
                    {
                        id: 'resonance',
                        name: 'Void Resonance',
                        desc: 'Multiplies all essence gains (void particles, cosmic particles, clicks, auto-gain) by +10% per level. Applies to everything.',
                        icon: '‚ö°',
                        getCost: (level) => Math.floor(1 * Math.pow(2, level)),
                        getEffect: (level) => `x${(1 + level * 0.1).toFixed(1)} total essence multiplier`,
                        color: '#bd00ff'
                    },
                    {
                        id: 'efficiency',
                        name: 'Quantum Efficiency',
                        desc: 'Reduces the cost scaling of all Infinity upgrades. Each level makes upgrade costs scale 5% slower, making it easier to reach higher levels.',
                        icon: '‚öõÔ∏è',
                        getCost: (level) => Math.floor(2 * Math.pow(2, level)),
                        getEffect: (level) => `Costs scale ${(level * 5).toFixed(0)}% slower`,
                        color: '#0ff'
                    },
                    {
                        id: 'density',
                        name: 'Particle Density',
                        desc: 'Increases the base number of void particles that spawn. Starts you with more particles every run, making early game faster.',
                        icon: '‚ú®',
                        getCost: (level) => Math.floor(3 * Math.pow(2, level)),
                        getEffect: (level) => `+${level * 5} starting void particles`,
                        color: '#ff6b9d'
                    },
                    {
                        id: 'cascade',
                        name: 'Essence Cascade',
                        desc: 'Lowers the Void Siphon level required for auto-gain to activate. Each level reduces the requirement by 2 levels (starts at level 10, goes to 8, 6, 4, 2, 0).',
                        icon: 'üåä',
                        getCost: (level) => Math.floor(5 * Math.pow(2, level)),
                        getEffect: (level) => `Auto-gain activates at level ${Math.max(0, 10 - level * 2)}`,
                        color: '#ffd700'
                    }
                ];
                
                upgrades.forEach(upgrade => {
                    const level = Game.singularityUpgrades[upgrade.id] || 0;
                    const cost = upgrade.getCost(level);
                    const effect = upgrade.getEffect(level);
                    
                    const card = document.createElement('div');
                    card.style.cssText = 'background:rgba(189,0,255,0.1); border:2px solid ' + upgrade.color + '; border-radius:10px; padding:15px; position:relative; overflow:hidden; transition:all 0.3s;';
                    card.innerHTML = `
                        <div style="font-size:1.5rem; margin-bottom:8px;">${upgrade.icon}</div>
                        <div style="font-family:"Orbitron"; font-size:1.1rem; color:#fff; font-weight:bold; margin-bottom:5px;">${upgrade.name}</div>
                        <div style="font-size:0.75rem; color:#aaa; margin-bottom:8px; line-height:1.4;">${upgrade.desc}</div>
                        <div style="font-size:0.9rem; color:${upgrade.color}; margin-bottom:10px; font-weight:bold; padding:5px; background:rgba(189,0,255,0.1); border-radius:5px;">Current: ${effect}</div>
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
                            <span style="font-size:0.85rem; color:#aaa;">Level ${level}</span>
                            <button class="singularity-upgrade-btn" data-upgrade="${upgrade.id}" style="background:${upgrade.color}; border:none; color:#fff; padding:8px 15px; border-radius:5px; cursor:pointer; font-weight:bold; transition:all 0.3s;" ${Game.singularityPoints < cost ? 'disabled' : ''}>Buy (${Format(cost)})</button>
                        </div>
                    `;
                    
                    if(Game.singularityPoints < cost) {
                        card.style.opacity = '0.6';
                        card.querySelector('button').style.opacity = '0.5';
                        card.querySelector('button').style.cursor = 'not-allowed';
                    } else {
                        card.style.cursor = 'pointer';
                        card.onmouseenter = () => card.style.transform = 'translateY(-3px)';
                        card.onmouseleave = () => card.style.transform = 'translateY(0)';
                        card.querySelector('button').onclick = (e) => {
                            e.stopPropagation();
                            if(Game.singularityPoints >= cost) {
                                Game.singularityPoints -= cost;
                                Game.singularityUpgrades[upgrade.id] = (Game.singularityUpgrades[upgrade.id] || 0) + 1;
                                Game.save();
                                this.updateSingularityUI();
                            }
                        };
                    }
                    
                    con.appendChild(card);
                });
            },
            updateMainDisplay() {
                if(Game.dimension === 1) {
                    document.getElementById('main-display-val').innerText = Format(Game.infinityPoints);
                    this.updateParticleRates();
                    // Update button states without rebuilding DOM to prevent hover issues
                    this.updateInfinityButtonStates();
                    // Update Singularity button visibility
                    const singularityBtn = document.getElementById('singularity-btn');
                    if(singularityBtn) {
                        const hasEnough = (Game.maxEssenceReached >= 1e8) || (Game.infinityPoints >= 1e8);
                        if(hasEnough) {
                            singularityBtn.style.display = 'block';
                        }
                    }
                    return;
                }
                const idx = Game.selectedRes; 
                let l = CONFIG.layers[idx];
                
                // Handle Reality Layer (Index 10)
                if(idx === 10) l = CONFIG.realityLayers[0];
                
                document.getElementById('main-display-val').innerText = Format(idx === 10 ? Game.reality.shards : Game.resources[idx]);
                document.getElementById('main-display-val').style.color = l.color;
                document.getElementById('main-display-name').innerText = `${l.currency} ‚ñº`;
                document.getElementById('main-display-name').style.color = l.color; 
            },
            updateRealtime() {
                // Display selected RPM (not always ring 0)
                let trueRPM = 0;
                if(Game.selectedRPM === 10 && Game.dimension === 2 && Game.reality.rings[0]) {
                    trueRPM = Game.reality.rings[0].velocity;
                } else if(Game.selectedRPM < Game.unlockedLayers) {
                    trueRPM = Game.rings[Game.selectedRPM].velocity;
                } else {
                    trueRPM = Game.rings[0].velocity;
                }
                document.getElementById('rpm-display').innerText = Format(trueRPM);
                
                for(let i=0; i<Game.unlockedLayers; i++) {
                    const el = document.getElementById(`rpm-item-${i}`);
                    if(el) {
                        let boost = Game.getSynergyBoost(i);
                        let boostText = boost > 1.0 ? `<span class="rpm-boost">(+${((boost-1)*100).toFixed(0)}%)</span>` : '';
                        el.innerHTML = `${Format(Game.rings[i].velocity)} ${boostText}`;
                        // Highlight selected RPM
                        if(Game.selectedRPM === i) {
                            el.style.backgroundColor = 'rgba(255,255,255,0.1)';
                        } else {
                            el.style.backgroundColor = '';
                        }
                    }
                }
                // Update Reality ring RPM if in Reality mode
                if(Game.dimension === 2) {
                    const el = document.getElementById('rpm-item-reality');
                    if(el && Game.reality.rings[0]) {
                        el.innerHTML = `${Format(Game.reality.rings[0].velocity)}`;
                        if(Game.selectedRPM === 10) {
                            el.style.backgroundColor = 'rgba(255,215,0,0.2)';
                        } else {
                            el.style.backgroundColor = '';
                        }
                    }
                }
                this.updateButtons(); this.updateMainDisplay(); this.updatePrestigeUI();
            },
            setLore(text) {
                const box = document.getElementById('lore-content'); box.innerHTML = text + '<span class="lore-blink"></span>';
                if(Game.dimension === 0) {
                    const color = CONFIG.layers[Game.unlockedLayers-1] ? CONFIG.layers[Game.unlockedLayers-1].color : '#fff';
                    document.getElementById('lore-box').style.borderColor = color;
                } else if (Game.dimension === 2) {
                     document.getElementById('lore-box').style.borderColor = "#ffd700";
                } else document.getElementById('lore-box').style.borderColor = "#40e0d0";
            },
            spawnText(text, layerIdx, isGradient = false, gradientType = 'gold') {
                if(!Game.settings.floaters) return;
                // Check per-layer toggle
                if(!isGradient && layerIdx !== undefined && !Game.floatersEnabled[layerIdx]) return;

                const el = document.createElement('div');
                el.className = 'floater';
                if(isGradient) {
                    if(gradientType === 'blue-purple') {
                        el.style.background = 'linear-gradient(135deg, #4169E1, #9370DB, #BA55D3)';
                        el.style.webkitBackgroundClip = 'text';
                        el.style.backgroundClip = 'text';
                        el.style.webkitTextFillColor = 'transparent';
                        el.style.textShadow = 'none';
                        el.style.fontSize = '1.5rem';
                        el.style.fontWeight = 'bold';
                    } else {
                        el.classList.add('reality-text'); // Apply big gold style if reality
                    }
                } else {
                    const color = CONFIG.layers[layerIdx] ? CONFIG.layers[layerIdx].color : '#fff';
                    el.style.color = color;
                    el.style.textShadow = `0 0 5px ${color}`;
                }
                
                el.innerText = text;
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                
                // Reality spawns higher
                const r = isGradient ? 150 : (CONFIG.baseRadius + (layerIdx * CONFIG.spacing));
                const ang = Math.random() * Math.PI * 2;
                
                // Use world coordinates that follow rings when camera moves
                const worldX = Math.cos(ang) * (r + 20);
                const worldY = Math.sin(ang) * (r + 20);
                // Convert world to screen coordinates accounting for camera
                const screenX = cx + (worldX * Renderer.zoom) + Renderer.cameraX;
                const screenY = cy + (worldY * Renderer.zoom) + Renderer.cameraY;
                
                el.style.left = screenX + 'px';
                el.style.top = screenY + 'px';

                document.body.appendChild(el);
                setTimeout(() => el.remove(), 1000);
            },
            buildAchievements() {
                const con = document.getElementById('ach-list-container');
                con.innerHTML = '';
                Achievements.list.forEach(a => {
                    const div = document.createElement('div');
                    div.className = `ach-list-item ${a.unlocked ? '' : 'locked'}`;
                    div.innerHTML = `<span class="ach-icon-sm">üèÜ</span><span style="font-family:'Orbitron'; font-size:0.8rem; color:${a.unlocked ? '#fff' : '#888'}">${a.name}</span>`;
                    con.appendChild(div);
                });
            },
            showAchievements() {
                this.buildAchievements();
            },
            updateChallengeInfo() {
                const panel = document.getElementById('challenge-info-panel');
                if(!panel) return;
                
                if(Game.reality && Game.reality.activeChallenge) {
                    const challenge = CONFIG.challenges.find(c => c.id === Game.reality.activeChallenge);
                    if(challenge) {
                        panel.style.display = 'block';
                        document.getElementById('challenge-info-name').innerText = challenge.name;
                        document.getElementById('challenge-info-desc').innerText = challenge.desc;
                        document.getElementById('challenge-info-reward').innerText = challenge.reward;
                    } else {
                        panel.style.display = 'none';
                    }
                } else {
                    panel.style.display = 'none';
                }
            },
            updateDimensionUI() {
                // Update button visibility based on game state
                const warpBtn = document.getElementById('warp-btn');
                const realityBtn = document.getElementById('reality-btn');
                const returnBtn = document.getElementById('return-btn');
                
                // Warp to Infinity should be visible in microcosm after unlocking (all layers or reality reached)
                if(this.dimension === 0 && (Game.unlockedLayers >= 10 || (Game.infinityPoints >= 1e12 || Game.artifacts.prism))) {
                    if(warpBtn) warpBtn.style.display = 'block';
                } else if(this.dimension !== 0) {
                    if(warpBtn) warpBtn.style.display = 'none';
                }
                
                // Reality button should be visible in Infinity mode once unlocked, and stay visible after first unlock
                if(this.dimension === 1 && (Game.infinityPoints >= 1e12 || Game.artifacts.prism)) {
                    if(realityBtn) realityBtn.style.display = 'block';
                } else if(this.dimension === 0 && (Game.infinityPoints >= 1e12 || Game.artifacts.prism)) {
                    // Also show in microcosm if already unlocked
                    if(realityBtn) realityBtn.style.display = 'block';
                } else if(this.dimension === 2) {
                    if(realityBtn) realityBtn.style.display = 'none';
                }
                
                // Update challenge info panel
                this.updateChallengeInfo();
            }
        };

        const Achievements = {
            list: [
                { id: "layer_2", name: "Biomass Unlocked", unlocked: false },
                { id: "layer_3", name: "Aether Unlocked", unlocked: false },
                { id: "layer_5", name: "Dark Matter Unlocked", unlocked: false },
                { id: "layer_8", name: "Chronos Unlocked", unlocked: false },
                { id: "singularity", name: "The Singularity", unlocked: false },
                { id: "prestige", name: "Time Traveler", unlocked: false }
            ],
            unlock(id) {
                const ach = this.list.find(a => a.id === id);
                if(ach && !ach.unlocked) {
                    ach.unlocked = true;
                }
            },
            show(title, desc, color) {
                const area = document.getElementById('popups'); const div = document.createElement('div'); div.className = 'achievement';
                div.style.setProperty('--c', color); div.innerHTML = `<div class="ach-icon">üèÜ</div><div class="ach-text"><h3>${title}</h3><p>${desc}</p></div>`;
                area.appendChild(div); setTimeout(()=>div.remove(), 6000);
            }
        };

        function Format(n) {
            if(n < 1000) return n.toFixed(2);
            const suffixes = ["k", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc", "Ud", "Dd", "Td", "Qad", "Qid"];
            const suffixNum = Math.floor(("" + Math.floor(n)).length / 3);
            let shortValue = parseFloat((suffixNum != 0 ? (n / Math.pow(1000, suffixNum)) : n).toPrecision(3));
            if (suffixNum > suffixes.length) return n.toExponential(2);
            return shortValue.toFixed(2) + suffixes[suffixNum - 1];
        }

        window.onload = () => Game.init();

        // OFFLINE PROGRESS - Page Visibility API
        document.addEventListener("visibilitychange", () => {
            if(document.hidden) {
                Game.hiddenTime = Date.now();
                Game.save(); // Save on hide for safety
            } else if(Game.hiddenTime) {
                const elapsed = (Date.now() - Game.hiddenTime) / 1000;
                const maxOffline = 12 * 60 * 60; // 12 hours cap
                const cappedTime = Math.min(elapsed, maxOffline);
                if(cappedTime > 1) {
                    Game.processOfflineProgress(cappedTime);
                }
                Game.hiddenTime = null;
            }
        });

    </script>
    <div style="position:fixed; bottom:5px; left:0; right:0; text-align:center; color:#9966ff; font-size:11px; opacity:0.7; pointer-events:none; z-index:1;">üíú Enhanced by Kova v8.3 ¬∑ Original by @tututi</div>
</body>
</html>